/**
 * WhatsApp - the open source AUTOSAR platform https://github.com/parai
 *
 * Copyright (C) 2014  WhatsApp <parai@foxmail.com>
 *
 * This source code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by the
 * Free Software Foundation; See <http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * Version: AUTOSAR 4.2.0
 * Generated by arxml.py
 */
#ifndef CANIF_TYPES_H
#define CANIF_TYPES_H

/* ============================ [ INCLUDES  ] ====================================================== */
#include "Std_Types.h"
#ifdef __cplusplus
namespace autosar {
extern "C" {
#endif
/* ============================ [ MACROS    ] ====================================================== */
/* ============================ [ TYPES     ] ====================================================== */
/* This container contains the configuration (parameters) of an adressed CAN controller by an underlying
 *  CAN Driver module. This container is configurable per CAN controller.
 */
typedef struct CanIf_CtrlCfgType_tag
{
/* Range: 0..number of configured controllers of all CAN Driver modules */
/* This parameter abstracts from the CAN Driver specific parameter Controller. Each controller
 *  of all connected CAN Driver modules shall be assigned to one specific ControllerId of the CanIf.
 */
	uint16 CanIfCtrlId ;
/* True: Enabled
                                                False: Disabled */
/* This parameter defines if a respective controller of the referenced CAN Driver modules is queriable
 *  for wake up events.
 */
	boolean CanIfCtrlWakeupSupport ;
/* This parameter references to the logical handle of the underlying CAN controller from the CAN
 *  Driver module to be served by the CAN Interface module. The following parameters of CanController
 *  config container shall be referenced by this link: CanControllerId, CanWakeupSourceRef
 */
/* Range: 0..max. number of underlying supported CAN controllers */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanController */
	Can_ControllerType* CanIfCtrlCanCtrlRef ;
} CanIf_CtrlCfgType ;

/* This parameter defines the name of <User_ClearTrcvWufFlagIndication>. */
/* TODO: 
 * typedef void (*CanIf_DispatchUserCheckTrcvWakeFlagIndicationNameType)(void);
 */

/* This parameter defines the upper layer module to which the CheckTrcvWakeFlagIndication from
 *  the Driver modules have to be routed.
 */
typedef enum
{
	CANIF_DISPATCHUSERCHECKTRCVWAKEFLAGINDICATIONUL_CAN_SM,
	CANIF_DISPATCHUSERCHECKTRCVWAKEFLAGINDICATIONUL_CDD
} CanIf_DispatchUserCheckTrcvWakeFlagIndicationULType ;

/* This parameter defines the name of <User_ClearTrcvWufFlagIndication>. */
/* TODO: 
 * typedef void (*CanIf_DispatchUserClearTrcvWufFlagIndicationNameType)(void);
 */

/* This parameter defines the upper layer module to which the ClearTrcvWufFlagIndication from the
 *  Driver modules have to be routed.
 */
typedef enum
{
	CANIF_DISPATCHUSERCLEARTRCVWUFFLAGINDICATIONUL_CAN_SM,
	CANIF_DISPATCHUSERCLEARTRCVWUFFLAGINDICATIONUL_CDD
} CanIf_DispatchUserClearTrcvWufFlagIndicationULType ;

/* This parameter defines the name of <User_ConfirmPnAvailability>. If CANIF_DISPATCH_USERCONFIRMPNAVAILABILITY_UL
 *  equals CAN_SM the name of <User_ConfirmPnAvailability> is fixed. If it equals CDD, the name
 *  is selectable. If CANIF_PUBLIC_PN_SUPPORT equals False, this parameter shall not be configurable.
 */
/* TODO: 
 * typedef void (*CanIf_DispatchUserConfirmPnAvailabilityNameType)(void);
 */

/* This parameter defines the upper layer module to which the ConfirmPnAvailability notification
 *  from the Driver modules have to be routed. If CANIF_PUBLIC_PN_SUPPORT equals False, this parameter
 *  shall not be configurable.
 */
typedef enum
{
	CANIF_DISPATCHUSERCONFIRMPNAVAILABILITYUL_CAN_SM,
	CANIF_DISPATCHUSERCONFIRMPNAVAILABILITYUL_CDD
} CanIf_DispatchUserConfirmPnAvailabilityULType ;

/* This parameter defines the name of <User_ControllerBusOff>. */
/* TODO: 
 * typedef void (*CanIf_DispatchUserCtrlBusOffNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the notifications of all ControllerBusOff
 *  events from the CAN Driver modules have to be routed via <User_ControllerBusOff>.
 */
typedef enum
{
	CANIF_DISPATCHUSERCTRLBUSOFFUL_CAN_SM,
	CANIF_DISPATCHUSERCTRLBUSOFFUL_CDD
} CanIf_DispatchUserCtrlBusOffULType ;

/* This parameter defines the name of <User_ControllerModeIndication>. */
/* TODO: 
 * typedef void (*CanIf_DispatchUserCtrlModeIndicationNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the notifications of all ControllerTransition
 *  events from the CAN Driver modules have to be routed
 */
typedef enum
{
	CANIF_DISPATCHUSERCTRLMODEINDICATIONUL_CAN_SM,
	CANIF_DISPATCHUSERCTRLMODEINDICATIONUL_CDD
} CanIf_DispatchUserCtrlModeIndicationULType ;

/* This parameter defines the name of <User_TrcvModeIndication>. */
/* TODO: 
 * typedef void (*CanIf_DispatchUserTrcvModeIndicationNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the notifications of all TransceiverTransition
 *  events from the CAN Transceiver Driver modules have to be routed via <User_TrcvModeIndication>.
 *  If no UL module is configured, no upper layer callback function will be called.
 */
typedef enum
{
	CANIF_DISPATCHUSERTRCVMODEINDICATIONUL_CAN_SM,
	CANIF_DISPATCHUSERTRCVMODEINDICATIONUL_CDD
} CanIf_DispatchUserTrcvModeIndicationULType ;

/* This parameter defines the name of <User_ValidateWakeupEvent>. This */
/* TODO: 
 * typedef void (*CanIf_DispatchUserValidateWakeupEventNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the notifications about positive
 *  former requested wake up sources have to be routed via <User_ValidateWakeupEvent>. If parameter
 *  CANIF_WAKEUP_CHECK_VALIDATION_API is disabled, this parameter cannot be configured.
 */
typedef enum
{
	CANIF_DISPATCHUSERVALIDATEWAKEUPEVENTUL_CDD,
	CANIF_DISPATCHUSERVALIDATEWAKEUPEVENTUL_ECUM
} CanIf_DispatchUserValidateWakeupEventULType ;

/* This container contains the Txbuffer configuration. Multiple buffers with different sizes could
 *  be configured. If CanIfBufferSize (CANIF834_Conf) equals 0, the CanIf Tx L-PDU only refers
 *  via this CanIfBufferCfg the corresponding CanIfHthCfg.
 */
typedef struct CanIf_BufferCfgType_tag
{
/* This parameter defines the number of CanIf Tx L-PDUs which can be buffered in one Txbuffer.
 *  If this value equals 0, the CanIf does not perform Txbuffering for the CanIf Tx L-PDUs which
 *  are assigned to this Txbuffer. If CanIfPublicTxBuffering equals False, this parameter equals
 *  0 for all TxBuffer. If the CanHandleType of the referred HTH equals FULL, this parameter equals
 *  0 for this TxBuffer.
 */
	uint8 CanIfBufferSize ;
/* Reference to HTH, that defines the hardware object or the pool of hardware objects configured
 *  for transmission. All the CanIf Tx L-PDUs refer via the CanIfBufferCfg and this parameter to
 *  the HTHs if TxBuffering is enabled, or not.
 */
/* Each HTH shall not be assigned to more than one buffer. */
/* /AUTOSAR/EcucDefs/CanIf/CanIfInitCfg/CanIfInitHohCfg/CanIfHthCfg */
	CanIf_HthCfgType* CanIfBufferHthRef ;
} CanIf_BufferCfgType ;

/* Specifies whether a configured Range of CAN Ids shall only consider standard CAN Ids or extended
 *  CAN Ids.
 */
typedef enum
{
	CANIF_HRHRANGERXPDURANGECANIDTYPE_EXTENDED,
	CANIF_HRHRANGERXPDURANGECANIDTYPE_STANDARD
} CanIf_HrhRangeRxPduRangeCanIdTypeType ;

/* Defines the parameters required for configurating multiple CANID ranges for a given same HRH. */
typedef struct CanIf_HrhRangeCfgType_tag
{
/* Lower CAN Identifier of a receive CAN L-PDU for identifier range definition, in which all CAN
 *  Ids shall pass the software filtering.
 */
	uint32 CanIfHrhRangeRxPduLowerCanId ;
	CanIf_HrhRangeRxPduRangeCanIdTypeType CanIfHrhRangeRxPduRangeCanIdType ;
/* Upper CAN Identifier of a receive CAN L-PDU for identifier range definition, in which all CAN
 *  Ids shall pass the software filtering.
 */
	uint32 CanIfHrhRangeRxPduUpperCanId ;
} CanIf_HrhRangeCfgType ;

/* This container contains configuration parameters for each hardware receive object (HRH). */
typedef struct CanIf_HrhCfgType_tag
{
	CanIf_HrhRangeCfgType* CanIfHrhRangeCfg ;
/* True: Software filtering is enabled
 *                                                         False: Software filtering is enabled
 */
/* Selects the hardware receive objects by using the HRH range/list from CAN Driver configuration
 *  to define, for which HRH a software filtering has to be performed at during receive processing.
 */
	boolean CanIfHrhSoftwareFilter ;
/* Reference to controller Id to which the HRH belongs to. A controller can contain one or more HRHs. */
/* /AUTOSAR/EcucDefs/CanIf/CanIfCtrlDrvCfg/CanIfCtrlCfg */
	CanIf_CtrlCfgType* CanIfHrhCanCtrlIdRef ;
/* The parameter refers to a particular HRH object in the CAN Driver Module configuration. The
 *  type of the HRH can either be Full-CAN or Basic-CAN. The type of HRHs is defined in the CAN
 *  Driver Module and hence it is derived from CAN Driver Configuration of a Hardware Object. If
 *  BasicCAN is configured, software filtering is enabled.
 */
/* Please note that this reference is deprecated and is kept only for backward compatibility reasons.
 *  CanIfHthIdSymRef shall be used instead to get the CanHandleType and CanObjectId of CAN Driver.
 *  In the next major release this reference will be deleted.
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject */
	Can_HardwareObjectType* CanIfHrhCanHandleTypeRef ;
/* The parameter refers to a particular HRH object in the CanDrv configuration (see CanHardwareObject
 *  CAN324_Conf).
 */
/* The CanIf receives the following information of the CanDrv module by this reference:
 *                                                         - CanHandleType (see CAN323_Conf)
 *                                                         - CanObjectId (see CAN326_Conf)
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject */
	Can_HardwareObjectType* CanIfHrhIdSymRef ;
} CanIf_HrhCfgType ;

/* This container contains parameters related to each HTH. */
typedef struct CanIf_HthCfgType_tag
{
/* Reference to controller Id to which the HTH belongs to. A controller can contain one or more HTHs. */
/* /AUTOSAR/EcucDefs/CanIf/CanIfCtrlDrvCfg/CanIfCtrlCfg */
	CanIf_CtrlCfgType* CanIfHthCanCtrlIdRef ;
/* The parameter refers to a particular HTH object in the CAN Driver Module configuration. The
 *  type of the HTH can either be Full-CAN or Basic-CAN. The type of HTHs is defined in the CAN
 *  Driver Module and hence it is derived from CAN Driver Configuration of a Hardware Object.
 */
/* Please note that this reference is deprecated and is kept only for backward compatibility reasons.
 *  CanIfHthIdSymRef shall be used instead to get the CanHandleType and CanObjectId of CAN Driver.
 *  In the next major release this reference will be deleted.
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject */
	Can_HardwareObjectType* CanIfHthCanHandleTypeRef ;
/* The parameter refers to a particular HTH object in the CanDrv configuration (see CanHardwareObject
 *  CAN324_Conf).
 */
/* The CanIf receives the following information of the CanDrv module by this reference:
 *                                                         - CanHandleType (see CAN323_Conf)
 *                                                         - CanObjectId (see CAN326_Conf)
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject */
	Can_HardwareObjectType* CanIfHthIdSymRef ;
} CanIf_HthCfgType ;

/* This container contains the references to the configuration setup of each underlying CAN Driver. */
typedef struct CanIf_InitHohCfgType_tag
{
	CanIf_HrhCfgType* CanIfHrhCfg ;
	CanIf_HthCfgType* CanIfHthCfg ;
/* Selects the CAN Interface specific configuration setup. This type of external data structure
 *  shall contain the post build initialization data for the CAN Interface for all underlying CAN
 *  Drivers.
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet */
	Can_ConfigSetType* CanIfInitRefCfgSet ;
} CanIf_InitHohCfgType ;

/* Optional container that allows to map a range of CAN Ids to one PduId. */
typedef struct CanIf_RxPduCanIdRangeType_tag
{
/* Lower CAN Identifier of a receive CAN L-PDU for identifier range definition, in which all CAN
 *  Ids are mapped to one PduId.
 */
	uint32 CanIfRxPduCanIdRangeLowerCanId ;
/* Upper CAN Identifier of a receive CAN L-PDU for identifier range definition, in which all CAN
 *  Ids are mapped to one PduId.
 */
	uint32 CanIfRxPduCanIdRangeUpperCanId ;
} CanIf_RxPduCanIdRangeType ;

/* This container is only included and valid if TTCAN Interface SWS is used and TTCAN is enabled. */
typedef struct CanIf_TTRxFrameTriggeringType_tag
{
/* Defines the point in time, when the joblist execution funciton (JLEF) shall be called for the
 *  referenced rx trigger. Value is given in cycle time. This parameter is only configurable if
 *  a joblist is enabled by parameter CanIfTTJobList.
 */
	uint16 CanTTRxJoblistTimeMark ;
/* This parameter refers to a particular TTCAN hardware receive object Trigger of a hardware object
 *  in the TTCAN Driver Module,  which is referred via plain CAN parameter CANIF_HRH_HANDLETYPE_REF.
 *  This parameter is only configurable if a joblist is enabled by parameter CanIfTTJobList.
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject/CanTTHardwareObjectTrigger */
	Can_TTHardwareObjectTriggerType* CanIfTTRxHwObjectTriggerIdRef ;
} CanIf_TTRxFrameTriggeringType ;

/* CAN Identifier of receive CAN L-PDUs used by the CAN Driver for CAN L-PDU reception. */
typedef enum
{
	CANIF_RXPDUCANIDTYPE_EXTENDED_CAN,
	CANIF_RXPDUCANIDTYPE_STANDARD_CAN
} CanIf_RxPduCanIdTypeType ;

/* This parameter defines the name of the <User_RxIndication>. */
/* TODO: 
 * typedef void (*CanIf_RxPduUserRxIndicationNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the indication */
typedef enum
{
	CANIF_RXPDUUSERRXINDICATIONUL_CAN_NM,
	CANIF_RXPDUUSERRXINDICATIONUL_CAN_TP,
	CANIF_RXPDUUSERRXINDICATIONUL_CDD,
	CANIF_RXPDUUSERRXINDICATIONUL_J1939TP,
	CANIF_RXPDUUSERRXINDICATIONUL_PDUR,
	CANIF_RXPDUUSERRXINDICATIONUL_XCP
} CanIf_RxPduUserRxIndicationULType ;

/* This container contains the configuration (parameters) of each receive CAN L-PDU. */
typedef struct CanIf_RxPduCfgType_tag
{
	CanIf_RxPduCanIdRangeType* CanIfRxPduCanIdRange ;
/* Frame trigger for TTCAN reception.
 * 
 *                                                 CanIfTTRxFrameTriggering is only included, if
 *  the controller supports TTCAN and a joblist is used for reception.
 */
	CanIf_TTRxFrameTriggeringType* CanIfTTRxFrameTriggering ;
/* Range: 11 Bit For Standard CAN Identifier ... 29 Bit For Extended CAN identifier */
/* CAN Identifier of Receive CAN L-PDUs used by the CAN Interface. Exa: Software Filtering. This
 *  parameter is used if exactly one Can Identifier is assigned to the Pdu. If a range is assigned
 *  then the CanIfRxPduCanIdRange parameter shall be used.
 */
	uint32 CanIfRxPduCanId ;
	CanIf_RxPduCanIdTypeType CanIfRxPduCanIdType ;
/* The data area size of a CAN L-PDU can have a range from 0 to 8 bytes. */
/* Data Length code of received CAN L-PDUs used by the CAN Interface. Exa: DLC check. */
	uint8 CanIfRxPduDlc ;
/* Range: 0..max. number of defined CanRxPduIds */
/* ECU wide unique, symbolic handle for receive CAN L-PDU. The CanIfRxPduId is configurable at
 *  pre-compile and post-built time. It shall fulfill ANSI/AUTOSAR definitions for constant defines.
 */
	uint32 CanIfRxPduId ;
/* True: Enabled
                                                False: Disabled */
/* Enables and disables the Rx buffering for reading of received L-PDU data. */
	boolean CanIfRxPduReadData ;
/* True: Enabled
                                                False: Disabled */
/* Enables and disables receive indication for each receive CAN L-PDU for reading its notification
 *  status.
 */
	boolean CanIfRxPduReadNotifyStatus ;
/* This parameter depends on the parameter CANIF_RXPDU_USERRXINDICATION_UL. If CANIF_RXPDU_USERRXINDICATION_UL
 *  equals CAN_TP, CAN_NM, PDUR, XCP or J1939TP, the name of the <User_RxIndication> is fixed.
 *  If CANIF_RXPDU_USERRXINDICATION_UL equals CDD, the name of the <User_RxIndication> is selectable.
 */
	CanIf_RxPduUserRxIndicationNameType CanIfRxPduUserRxIndicationName ;
/* of the successfully received CANRXPDUID has to be routed via <User_RxIndication>. This <User_RxIndication>
 *  has to be invoked when the 
 *                                                 indication of the configured CANRXPDUID will
 *  be received by an Rx indication event from the CAN Driver module. If no upper layer (UL) module
 *  
 *                                                 is configured, no <User_RxIndication> has to
 *  be called in case of an Rx 
 *                                                 indication event of the CANRXPDUID from the
 *  CAN Driver module.
 */
	CanIf_RxPduUserRxIndicationULType CanIfRxPduUserRxIndicationUL ;
/* Reference to an exclusive area Id defined within the BSW Scheduler. */
/* /AUTOSAR/EcucDefs/Rte/RteBswModuleInstance/RteBswExclusiveAreaImpl */
	Rte_BswExclusiveAreaImplType* CanIfRxPduBswSchExclAreaIdRef ;
/* The HRH to which Rx L-PDU belongs to, is referred through this parameter. */
/* /AUTOSAR/EcucDefs/CanIf/CanIfInitCfg/CanIfInitHohCfg/CanIfHrhCfg */
	CanIf_HrhCfgType* CanIfRxPduHrhIdRef ;
/* Reference to the "global" Pdu structure to allow harmonization of handle IDs in the COM-Stack. */
/* /AUTOSAR/EcucDefs/EcuC/EcucPduCollection/Pdu */
	EcuC_PduType* CanIfRxPduRef ;
} CanIf_RxPduCfgType ;

/* This container is only included and valid if TTCAN Interface SWS is used and TTCAN is enabled. */
typedef struct CanIf_TTTxFrameTriggeringType_tag
{
/* Value is given in cycle time. This parameter is only configurable if a joblist is enabled by
 *  parameter CanIfTTJobList.
 */
/* Defines the point in time, when the joblist execution funciton (JLEF) shall be called for the
 *  referenced tx frame trigger.
 */
	uint16 CanIfTTTxJoblistTimeMark ;
/* This parameter refers to a particular TTCAN hardware transmit object Trigger of a hardware object
 *  in the TTCAN Driver Module,
 */
/* which is referred via plain CAN parameter CANIF_HTH_HANDLETYPE_REF. This parameter is only configurable
 *  if a joblist is enabled by parameter CanIfTTJobList.
 */
/* /AUTOSAR/EcucDefs/Can/CanConfigSet/CanHardwareObject/CanTTHardwareObjectTrigger */
	Can_TTHardwareObjectTriggerType* CanIfTTTxHwObjectTriggerIdRef ;
} CanIf_TTTxFrameTriggeringType ;

/* Type of CAN Identifier of the transmit CAN L-PDU used by the CAN Driver module for CAN L-PDU
 *  transmission.
 */
typedef enum
{
	CANIF_TXPDUCANIDTYPE_EXTENDED_CAN,
	CANIF_TXPDUCANIDTYPE_STANDARD_CAN
} CanIf_TxPduCanIdTypeType ;

/* Defines the type of each transmit CAN L-PDU. */
typedef enum
{
	CANIF_TXPDUTYPE_DYNAMIC,
	CANIF_TXPDUTYPE_STATIC
} CanIf_TxPduTypeType ;

/* This parameter defines the name of the <User_TxConfirmation>. This */
/* TODO: 
 * typedef void (*CanIf_TxPduUserTxConfirmationNameType)(void);
 */

/* This parameter defines the upper layer (UL) module to which the confirmation of the successfully
 *  transmitted CANTXPDUID has to be routed via the <User_TxConfirmation>.
 */
typedef enum
{
	CANIF_TXPDUUSERTXCONFIRMATIONUL_CAN_NM,
	CANIF_TXPDUUSERTXCONFIRMATIONUL_CAN_TP,
	CANIF_TXPDUUSERTXCONFIRMATIONUL_CDD,
	CANIF_TXPDUUSERTXCONFIRMATIONUL_J1939TP,
	CANIF_TXPDUUSERTXCONFIRMATIONUL_PDUR,
	CANIF_TXPDUUSERTXCONFIRMATIONUL_XCP
} CanIf_TxPduUserTxConfirmationULType ;

/* This container contains the configuration (parameters) of a transmit CAN L-PDU. It has to be
 *  configured as often as a transmit CAN L-PDU is needed.
 */
typedef struct CanIf_TxPduCfgType_tag
{
/* Frame trigger for TTCAN transmission.
 * 
 *                                                 CanIfTTTxFrameTriggering is only included, if
 *  the controller supports TTCAN and a joblist is used.
 */
	CanIf_TTTxFrameTriggeringType* CanIfTTTxFrameTriggering ;
/* Range: 11 Bit For Standard CAN Identifier ... 29 Bit For Extended CAN identifier */
/* CAN Identifier of transmit CAN L-PDUs used by the CAN Driver for CAN L-PDU transmission. */
	uint32 CanIfTxPduCanId ;
	CanIf_TxPduCanIdTypeType CanIfTxPduCanIdType ;
/* The data area size of a CAN L-Pdu can have a range from 0 to 8 bytes. */
/* Data length code (in bytes) of transmit CAN L-PDUs used by the CAN Driver for CAN L-PDU transmission.
 */
	uint8 CanIfTxPduDlc ;
/* Range: 0..max. number of CantTxPduIds */
/* ECU wide unique, symbolic handle for transmit CAN L-PDU. The CanIfTxPduId is configurable at
 *  pre-compile and post-built time.
 */
	uint32 CanIfTxPduId ;
/* If there is no CanIfTxPduPnFilterPdu configured per controller, the corresponding controller
 *  applies no CanIfPnFilter.
 */
/* If CanIfPublicPnFilterSupport is enabled, by this parameter PDUs could be configured which will
 *  pass the CanIfPnFilter.
 */
	boolean CanIfTxPduPnFilterPdu ;
/* True: Enabled
                                                False: Disabled */
/* Enables and disables transmit confirmation for each transmit CAN L-PDU for reading its notification
 *  status.
 */
	boolean CanIfTxPduReadNotifyStatus ;
	CanIf_TxPduTypeType CanIfTxPduType ;
/* parameter depends on the parameter CANIF_TXPDU_USERTXCONFIRMATION_UL. If 
 *                                                 CANIF_TXPDU_USERTXCONFIRMATION_UL equals CAN_TP,
 *  CAN_NM, PDUR, XCP or J1939TP,  the name of the <User_TxConfirmation> is fixed. If CANIF_TXPDU_USERTXCONFIRMATION_UL
 *  equals CDD, the name of the <User_TxConfirmation> is selectable.
 */
	CanIf_TxPduUserTxConfirmationNameType CanIfTxPduUserTxConfirmationName ;
/* This <User_TxConfirmation> has to be invoked when the confirmation of the configured CANTXPDUID
 *  will be received by a Tx confirmation event from the CAN Driver module.
 *                                                 If no upper layer (UL) module is configured,
 *  no <User_TxConfirmation> has to be called in case of a Tx confirmation event of the CANTXPDUID
 *  from the CAN Driver module.
 */
	CanIf_TxPduUserTxConfirmationULType CanIfTxPduUserTxConfirmationUL ;
/* Reference to an exclusive area Id defined within the BSW Scheduler. */
/* /AUTOSAR/EcucDefs/Rte/RteBswModuleInstance/RteBswExclusiveAreaImpl */
	Rte_BswExclusiveAreaImplType* CanIfTxPduBswSchExclAreaIdRef ;
/* Configurable reference to a CanIf buffer configuration. */
/* /AUTOSAR/EcucDefs/CanIf/CanIfInitCfg/CanIfBufferCfg */
	CanIf_BufferCfgType* CanIfTxPduBufferRef ;
/* Reference to the "global" Pdu structure to allow harmonization of handle IDs in the COM-Stack. */
/* /AUTOSAR/EcucDefs/EcuC/EcucPduCollection/Pdu */
	EcuC_PduType* CanIfTxPduRef ;
} CanIf_TxPduCfgType ;

/* This container is only included and valid if TTCAN Interface SWS is used and TTCAN is enabled. */
typedef struct CanIf_TTGeneralType_tag
{
/* TRUE: Joblist is used. 
 *                                                 FALSE: No joblist is used.
 * 
 *                                                 This parameter is only configurable if TTCAN
 *  is enabled by parameter CanIfSupportTTCAN.
 */
/* Defines whether TTCAN is processed via a joblist. */
	boolean CanIfTTJoblist ;
/* Defines the maximum delay for the execution of the joblist execution function JLEF. This parameter
 *  is only configurable if a joblist is enabled by parameter CanIfTTJobList.
 */
	uint16 CanIfTTMaxIsrDelay ;
} CanIf_TTGeneralType ;

/* Selects the desired software filter mechanism for reception only. */
typedef enum
{
	CANIF_PRIVATESOFTWAREFILTERTYPE_BINARY,
	CANIF_PRIVATESOFTWAREFILTERTYPE_INDEX,
	CANIF_PRIVATESOFTWAREFILTERTYPE_LINEAR,
	CANIF_PRIVATESOFTWAREFILTERTYPE_TABLE
} CanIf_PrivateSoftwareFilterTypeType ;

/* This parameter is used to configure the Can_HwHandleType. The Can_HwHandleType represents the
 *  hardware object handles of a CAN hardware unit. For CAN hardware units with more than 255 HW
 *  objects the extended range shall be used (UINT16).
 */
typedef enum
{
	CANIF_PUBLICHANDLETYPEENUM_UINT16,
	CANIF_PUBLICHANDLETYPEENUM_UINT8
} CanIf_PublicHandleTypeEnumType ;

/* This container contains the configuration (parameters) of one addressed CAN transceiver by the
 *  underlying CAN Transceiver Driver module. For each CAN transceiver a seperate instance of this
 *  container has to be provided.
 */
typedef struct CanIf_TrcvCfgType_tag
{
/* Range: 0..number of configured transceivers of all CAN Transceiver Driver modules */
/* This parameter abstracts from the CAN Transceiver Driver specific parameter Transceiver. Each
 *  transceiver of all connected CAN Transceiver Driver modules shall be assigned to one specific
 *  TransceiverId of the CanIf.
 */
	uint16 CanIfTrcvId ;
/* True: Enabled
                                                False: Disabled */
/* This parameter defines if a respective transceiver of the referenced CAN Transceiver Driver
 *  modules is queriable for wake up events.
 */
	boolean CanIfTrcvWakeupSupport ;
/* This parameter references to the logical handle of the underlying CAN */
/* transceiver from the CAN transceiver driver module to be served by the CAN Interface module.
 * 
 *                                                 Range: 0..max. number of underlying supported
 *  CAN transceivers
 */
/* /AUTOSAR/EcucDefs/CanTrcv/CanTrcvConfigSet/CanTrcvChannel */
	CanTrcv_ChannelType* CanIfTrcvCanTrcvRef ;
} CanIf_TrcvCfgType ;

/* Configuration parameters for all the underlying CAN Driver modules are aggregated under this
 *  container. For each CAN Driver module a seperate instance of this container has to be provided.
 */
typedef struct CanIf_CtrlDrvCfgType_tag
{
	CanIf_CtrlCfgType* CanIfCtrlCfg ;
/* True: Enabled
                                        False: Disabled */
/* Selects whether transmit cancellation is supported and if the appropriate callback will be provided
 *  to the CAN Driver module.
 */
	boolean CanIfCtrlDrvTxCancellation ;
/* Reference to the Init Hoh Configuration */
/* /AUTOSAR/EcucDefs/CanIf/CanIfInitCfg/CanIfInitHohCfg */
	CanIf_InitHohCfgType* CanIfCtrlDrvInitHohConfigRef ;
/* CAN Interface Driver Reference. */
/* This reference can be used to get any information (Ex. Driver Name, Vendor ID) from the CAN
 *  driver.
 * 
 *                                         The CAN Driver name can be derived from the ShortName
 *  of the CAN driver module.
 */
/* /AUTOSAR/EcucDefs/Can/CanGeneral */
	Can_GeneralType* CanIfCtrlDrvNameRef ;
} CanIf_CtrlDrvCfgType ;

/* Callback functions provided by upper layer modules of the CanIf. The callback functions defined
 *  in this container are common to all configured CAN Driver / CAN Transceiver Driver modules.
 */
typedef struct CanIf_DispatchCfgType_tag
{
/* If CANIF_DISPATCH_USERCHECKTRCVWAKEFLAGINDICATION_UL equals CAN_SM the name of <User_CheckTrcvWakeFlagIndication>
 *  is fixed. If it equals CDD, the name is selectable. If CANIF_PUBLIC_PN_SUPPORT equals False,
 *  this parameter shall not be configurable.
 */
	CanIf_DispatchUserCheckTrcvWakeFlagIndicationNameType CanIfDispatchUserCheckTrcvWakeFlagIndicationName ;
/* If CANIF_PUBLIC_PN_SUPPORT equals False, this parameter shall not be configurable. */
	CanIf_DispatchUserCheckTrcvWakeFlagIndicationULType CanIfDispatchUserCheckTrcvWakeFlagIndicationUL ;
/* If CANIF_DISPATCH_USERCLEARTRCVWUFFLAGINDICATION_UL equals CAN_SM the name of <User_ClearTrcvWufFlagIndication>
 *  is fixed. If it equals CDD, the name is selectable. If CANIF_PUBLIC_PN_SUPPORT equals False,
 *  this parameter shall not be configurable.
 */
	CanIf_DispatchUserClearTrcvWufFlagIndicationNameType CanIfDispatchUserClearTrcvWufFlagIndicationName ;
/* If CANIF_PUBLIC_PN_SUPPORT equals False, this parameter shall not be configurable. */
	CanIf_DispatchUserClearTrcvWufFlagIndicationULType CanIfDispatchUserClearTrcvWufFlagIndicationUL ;
	CanIf_DispatchUserConfirmPnAvailabilityNameType CanIfDispatchUserConfirmPnAvailabilityName ;
	CanIf_DispatchUserConfirmPnAvailabilityULType CanIfDispatchUserConfirmPnAvailabilityUL ;
/* This parameter depends on the parameter CANIF_USERCTRLBUSOFF_UL. If CANIF_USERCTRLBUSOFF_UL
 *  equals CAN_SM the name of <User_ControllerBusOff> is fixed. If CANIF_USERCTRLBUSOFF_UL equals
 *  CDD, the name of <User_ControllerBusOff> is selectable.
 */
	CanIf_DispatchUserCtrlBusOffNameType CanIfDispatchUserCtrlBusOffName ;
/* There is no possibility to configure no upper layer (UL) module as the provider of <User_ControllerBusOff>.
 */
	CanIf_DispatchUserCtrlBusOffULType CanIfDispatchUserCtrlBusOffUL ;
/* This parameter depends on the parameter CANIF_USERCTRLMODEINDICATION_UL. If CANIF_USERCTRLMODEINDICATION_UL
 *  equals CAN_SM the name of <User_ControllerModeIndication> is fixed. If CANIF_USERCTRLMODEINDICATION_UL
 *  equals CDD, the name of <User_ControllerModeIndication> is selectable.
 */
	CanIf_DispatchUserCtrlModeIndicationNameType CanIfDispatchUserCtrlModeIndicationName ;
/* via <User_ControllerModeIndication>. */
	CanIf_DispatchUserCtrlModeIndicationULType CanIfDispatchUserCtrlModeIndicationUL ;
/* This parameter depends on the parameter CANIF_USERTRCVMODEINDICATION_UL. If CANIF_USERTRCVMODEINDICATION_UL
 *  equals CAN_SM the name of <User_TrcvModeIndication> is fixed. If CANIF_USERTRCVMODEINDICATION_UL
 *  equals CDD, the name of <User_TrcvModeIndication> is selectable.
 */
	CanIf_DispatchUserTrcvModeIndicationNameType CanIfDispatchUserTrcvModeIndicationName ;
	CanIf_DispatchUserTrcvModeIndicationULType CanIfDispatchUserTrcvModeIndicationUL ;
/* parameter depends on the parameter CANIF_USERVALIDATEWAKEUPEVENT_UL. 
 *                                         CANIF_USERVALIDATEWAKEUPEVENT_UL equals ECUM the name
 *  of 
 *                                         <User_ValidateWakeupEvent> is fixed. CANIF_USERVALIDATEWAKEUPEVENT_UL
 *  equals CDD, the name of <User_ValidateWakeupEvent> is selectable. If parameter CANIF_WAKEUP_CHECK_VALIDATION_API
 *  is disabled, no <User_ValidateWakeupEvent> API can be configured.
 */
	CanIf_DispatchUserValidateWakeupEventNameType CanIfDispatchUserValidateWakeupEventName ;
	CanIf_DispatchUserValidateWakeupEventULType CanIfDispatchUserValidateWakeupEventUL ;
} CanIf_DispatchCfgType ;

/* This container contains the init parameters of the CAN Interface. */
typedef struct CanIf_InitCfgType_tag
{
	CanIf_BufferCfgType* CanIfBufferCfg ;
	CanIf_InitHohCfgType* CanIfInitHohCfg ;
/* The SHORT-NAME of "CanIfRxPduConfig" container itself represents the symolic name of Receive
 *  L-PDU.
 */
	CanIf_RxPduCfgType* CanIfRxPduCfg ;
/* The SHORT-NAME of "CanIfTxPduConfig" container represents the symolic name of Transmit L-PDU. */
	CanIf_TxPduCfgType* CanIfTxPduCfg ;
/* constant to CanIf_ConfigType */
/* Selects the CAN Interface specific configuration setup. This type of the external data structure
 *  shall contain the post build initialization data for the CAN Interface for all underlying CAN
 *  Dirvers.
 */
	char* CanIfInitCfgSet ;
} CanIf_InitCfgType ;

/* This container contains the private configuration (parameters) of the CAN Interface. */
typedef struct CanIf_PrivateCfgType_tag
{
/* This container contains the parameters, which define if and in which way TTCAN is supported.
 * 
 *                                         CanIfTTGeneral is only included, if the controller supports
 *  TTCAN.
 */
	CanIf_TTGeneralType* CanIfTTGeneral ;
/* True: Enabled
                                        False: Disabled */
/* Selects whether the DLC check is supported. */
	boolean CanIfPrivateDlcCheck ;
/* Each implemented software filtering method is identified by this enumeration number.
 * 
 *                                         Range: Types implemented software filtering methods
 */
	CanIf_PrivateSoftwareFilterTypeType CanIfPrivateSoftwareFilterType ;
/* TRUE: TTCAN is supported.
 *                                         FALSE: TTCAN is not supported, only normal CAN communication
 *  is possible.
 */
/* Defines whether TTCAN is supported. */
	boolean CanIfSupportTTCAN ;
} CanIf_PrivateCfgType ;

/* This container contains the public configuration (parameters) of the CAN Interface. */
typedef struct CanIf_PublicCfgType_tag
{
/* Configuration parameter to enable/disable dummy API for upper layer modules which allows to
 *  request the cancellation of an I-PDU.
 */
	boolean CanIfPublicCancelTransmitSupport ;
/* Defines header files for callback functions which shall be included in case of CDDs. Range of
 *  characters is 1.. 32.
 */
	char* CanIfPublicCddHeaderFile ;
/* True: Enabled
                                        False: Disabled */
/* Configuration parameter to enable/disable the API to change the baudrate of a CAN controller. */
	boolean CanIfPublicChangeBaudrateSupport ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the development error detection and notification mechanism. */
	boolean CanIfPublicDevErrorDetect ;
	CanIf_PublicHandleTypeEnumType CanIfPublicHandleTypeEnum ;
/* True: Enabled
                                        False: Disabled */
/* Selects support for multiple CAN Drivers. */
	boolean CanIfPublicMultipleDrvSupport ;
/* Number of served CAN hardware units. */
	uint8 CanIfPublicNumberOfCanHwUnits ;
/* True: Enabled
                                          False: Disabled */
/* Selects support of Partial Network features in CanIf. */
	boolean CanIfPublicPnSupport ;
/* True: Enabled
                                        False: Disabled */
/* Enables / Disables the API CanIf_ReadRxPduData() for reading received L-PDU data. */
	boolean CanIfPublicReadRxPduDataApi ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the API for reading the received L-PDU data. */
	boolean CanIfPublicReadRxPduNotifyStatusApi ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the API for reading the notification status of transmit and receive L-PDUs. */
	boolean CanIfPublicReadTxPduNotifyStatusApi ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the API for reconfiguration of the CAN Identifier for each Transmit L-PDU. */
	boolean CanIfPublicSetDynamicTxIdApi ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the buffering of transmit L-PDUs (rejected by the CanDrv) within the CAN
 *  Interface module.
 */
	boolean CanIfPublicTxBuffering ;
/* Configuration parameter to enable/disable the API to poll for Tx Confirmation state. */
	boolean CanIfPublicTxConfirmPollingSupport ;
/* True: Enabled
                                        False: Disabled */
/* Enables and disables the API  for reading the version information about the CAN Interface. */
	boolean CanIfPublicVersionInfoApi ;
/* (see CANIF722) at the corresponding wake-up source in the CanIf.
 *                                         If disabled, all messages shall validate such a wake-up
 *  event.
 *                                         This parameter depends on CANIF_PUBLIC_WAKEUP_CHECK_VALID_API
 *  and shall only be configurable, if it is enabled.
 * 
 *                                         True: Enabled
 *                                         False: Disabled
 */
/* If enabled, only NM messages shall validate a detected wake-up event */
	boolean CanIfPublicWakeupCheckValidByNM ;
/* True: Enabled
                                        False: Disabled */
/* Selects support for wake up validation */
	boolean CanIfPublicWakeupCheckValidSupport ;
} CanIf_PublicCfgType ;

/* This container contains the configuration (parameters) of all addressed CAN transceivers by
 *  each underlying CAN Transceiver Driver module. For each CAN transceiver Driver a seperate instance
 *  of this container shall be provided.
 */
typedef struct CanIf_TrcvDrvCfgType_tag
{
	CanIf_TrcvCfgType* CanIfTrcvCfg ;
} CanIf_TrcvDrvCfgType ;

/* ============================ [ DATAS     ] ====================================================== */
/* ============================ [ DECLARES  ] ====================================================== */
/* ============================ [ LOCALS    ] ====================================================== */
/* ============================ [ FUNCTIONS ] ====================================================== */
#ifdef __cplusplus
}}  /* name space */
#endif
#endif /* CANIF_TYPES_H */

