/**
 * WhatsApp - the open source AUTOSAR platform https://github.com/parai
 *
 * Copyright (C) 2014  WhatsApp <parai@foxmail.com>
 *
 * This source code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 as published by the
 * Free Software Foundation; See <http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt>.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * for more details.
 * Version: AUTOSAR 4.2.0
 * Generated by arxml.py
 */
#ifndef DCM_TYPES_H
#define DCM_TYPES_H

/* ============================ [ INCLUDES  ] ====================================================== */
#include "Std_Types.h"
#ifdef __cplusplus
namespace autosar {
extern "C" {
#endif
/* ============================ [ MACROS    ] ====================================================== */
/* ============================ [ TYPES     ] ====================================================== */
/* Callback function of the ECU Supplier specific component. This parameter is related to the interface
 *  <Module>_<DiagnosticService>_<SubService>.
 */
/* TODO: 
 * typedef void (*Dcm_DsdSubServiceFncType)(void);
 */

/* This container contains the configuration (DSD parameters) for SubServices. This configuration
 *  is available only for services having Subfunction: this container exists only if parameter
 *  DcmDsdSidTabSubfuncAvail, of this service, is set to TRUE and the parameter DcmDsdSidTabFnc
 *  is not existing.
 */
typedef struct Dcm_DsdSubServiceType_tag
{
/* If it is not configured the sub-service is handled Dcm-internally. */
	Dcm_DsdSubServiceFncType DcmDsdSubServiceFnc ;
/* Id of the SubService identifier. The possible Subfunction parameter value are predefined in
 *  the ISO 14229-1 and ISO 15031-5.
 */
	uint8 DcmDsdSubServiceId ;
/* Reference to DcmDspModeRule */
/* Mode rule which controls execution of this the DcmDsdSubService. If there is no reference, no
 *  check of the mode rule shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDsdSubServiceModeRuleRef ;
/* Link to the Security Level needed for execution of the DcmDsdSubService. */
/* Please refer to the ISO 14229-1, ISO 15031-5 and "Verification of the Diagnostic Session". 
 * 
 *                                                                         Please note, that it
 *  shall be provided to configure several DcmDsdSubServiceSecurityLevelRef per DcmDsdSubService.
 *  If there is no reference, no check of security level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDsdSubServiceSecurityLevelRef ;
/* Link to the Session Control needed for execution of the DcmDsdSubService. */
/* Please refer to the ISO 14229-1, ISO 15031-5 and "Verification of the Diagnostic Session". 
 * 
 *                                                                         Please note, that it
 *  shall be provided to configure several DcmDsdSubServiceSessionLevelRef per DcmDsdSubService.
 *  If there is no reference, no check of session level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDsdSubServiceSessionLevelRef ;
} Dcm_DsdSubServiceType ;

/* Callback function of the ECU Supplier specific component for the particular DcmDsdSidTabServiceId. */
/* TODO: 
 * typedef void (*Dcm_DsdSidTabFncType)(void);
 */

/* This container contains the configuration (DSD parameters) for Service. */
typedef struct Dcm_DsdServiceType_tag
{
	Dcm_DsdSubServiceType* DcmDsdSubService ;
/* This parameter is related to the interface <Module>_<DiagnosticService>. If it is not configured
 *  the service is handled Dcm-internally.
 */
	Dcm_DsdSidTabFncType DcmDsdSidTabFnc ;
/* The possible Service identifier are predefined in the ISO 14229-1 and ISO 15031-5 and in Table
 *  4 and Table 5.
 */
/* Id of the Service identifier. */
	uint8 DcmDsdSidTabServiceId ;
/* true = sub-function available
 *                                                                 false = sub-function not available
 */
/* Information whether the DcmDsdSidTabServiceId includes Sub functions or not. Used for the Handling
 *  of "suppressPosRspMsgIndicationBit" ISO14229-1 can be referenced here, as this specification
 *  gives fix definition, if an SID includes Subfunction or not.
 */
	boolean DcmDsdSidTabSubfuncAvail ;
/* Reference to DcmDspModeRule */
/* Mode rule which controls the execution of the DcmDsdService. If there is no reference, no check
 *  of the mode rule shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDsdSidTabModeRuleRef ;
/* Link to the Security Access Levels needed for execution of the DcmDsdService. */
/* Please refer to the ISO 14229-1, ISO 15031-5 and "Verification of the Security Access levels".
 *  Please note, that it shall be provided to configure several DcmDsdSidTabSecurityLevelRef per
 *  DcmDsdService. 
 *                                                                 If there is no reference, no
 *  check of security level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDsdSidTabSecurityLevelRef ;
/* Link to the Session Control needed for execution of the DcmDsdService. Please refer to the ISO
 *  14229-1, ISO 15031-5 and "Verification of the Diagnostic Session". Please note, that it shall
 *  be provided to configure several DcmDsdSidTabSessionLevelRef per DcmDsdService. If there is
 *  no reference, no check of session level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDsdSidTabSessionLevelRef ;
} Dcm_DsdServiceType ;

/* This container contains the configuration (DSD parameters) for Service Identifier Table. */
typedef struct Dcm_DsdServiceTableType_tag
{
	Dcm_DsdServiceType* DcmDsdService ;
/* Due the fact of using one or more service tables the member of the Service Identifier Table
 *  includes a unique id for the Service Identifier Table.
 */
	uint8 DcmDsdSidTabId ;
} Dcm_DsdServiceTableType ;

/* These parameters apply to Diagnostic Service Dispatcher. All parameters for all service dispatchers
 *  are included in this one configuration container.
 */
typedef struct Dcm_DsdType_tag
{
	Dcm_DsdServiceTableType* DcmDsdServiceTable ;
} Dcm_DsdType ;

/* This container contains the configuration (parameters) for the diagnostic buffer. */
typedef struct Dcm_DslBufferType_tag
{
/* For a linear buffer: size of the buffer shall be as large as the longest 
 *                                                         message (request or response)
 * 
 *                                                         For a paged buffer (only Tx possible):
 *  size has impacts on the application performance
 * 
 *                                                         Please note: max. range is the valid
 *  range for a CAN network. We assume a FlexRay (or other networks) implementation will work with
 *  this range (and the page buffer mechanism) without any problems.
 */
/* Size of Diagnostic Buffer (in Bytes) */
	uint32 DcmDslBufferSize ;
} Dcm_DslBufferType ;

/* The name of this container is used to define the name of the R-Port through which the DCM access
 *  the interface CallbackDCMRequestServices.
 */
typedef struct Dcm_DslCallbackDCMRequestServiceType_tag
{
} Dcm_DslCallbackDCMRequestServiceType ;

/* This container contains the configuration (parameters) for the ResponsePending handling */
typedef struct Dcm_DslDiagRespType_tag
{
/* Value 0xFF means that no limit number of NRC 0x78 response apply. */
/* Maximum number of negative responses with response code 0x78 (requestCorrectlyReceived-ResponsePending)
 *  allowed per request. DCM will send a negative response with response code 0x10            
 *      (generalReject), in case the limit value gets reached.
 */
	uint8 DcmDslDiagRespMaxNumRespPend ;
/* TRUE: when the second request (Client B) can not be processed, it shall be answered with NRC21
 *  BusyRepeatRequest.
 * 
 *                                                         FALSE: when the second request (Client
 *  B) can not be processed, it shall not be responded.
 */
/* Defines the reaction upon a second request (ClientB) that can not be processed (e.g. due to
 *  priority assessment).
 */
	boolean DcmDslDiagRespOnSecondDeclinedRequest ;
} Dcm_DslDiagRespType ;

/* This container contains links between Diagnostic Protocol (=DcmDslProtocolRow) and the according
 *  Rx or Tx channel.
 */
typedef struct Dcm_DslConnectionType_tag
{
} Dcm_DslConnectionType ;

/* The diagnostic protocol type for the DCM DSL protocol that is being configured. */
typedef enum
{
	DCM_OBD_ON_CAN,
	DCM_OBD_ON_FLEXRAY,
	DCM_OBD_ON_IP,
	DCM_PERIODICTRANS_ON_IP,
	DCM_PERIODIC_ON_CAN,
	DCM_PERIODIC_ON_FLEXRAY,
	DCM_ROE_ON_CAN,
	DCM_ROE_ON_FLEXRAY,
	DCM_ROE_ON_IP,
	DCM_SUPPLIER_1,
	DCM_SUPPLIER_10,
	DCM_SUPPLIER_11,
	DCM_SUPPLIER_12,
	DCM_SUPPLIER_13,
	DCM_SUPPLIER_14,
	DCM_SUPPLIER_15,
	DCM_SUPPLIER_2,
	DCM_SUPPLIER_3,
	DCM_SUPPLIER_4,
	DCM_SUPPLIER_5,
	DCM_SUPPLIER_6,
	DCM_SUPPLIER_7,
	DCM_SUPPLIER_8,
	DCM_SUPPLIER_9,
	DCM_UDS_ON_CAN,
	DCM_UDS_ON_FLEXRAY,
	DCM_UDS_ON_IP
} Dcm_DslProtocolIDType ;

/* Selects the transmission type for protocol. */
typedef enum
{
	DCM_DSLPROTOCOLTRANSTYPE_TYPE1,
	DCM_DSLPROTOCOLTRANSTYPE_TYPE2
} Dcm_DslProtocolTransTypeType ;

/* Definition of a single Row of configuration for the protocol configuration (for each protocol) */
typedef struct Dcm_DslProtocolRowType_tag
{
/* Because of the usecase to allow more then one diagnostic tester (using different CAN channels)
 *  it is necessary to allow configuration of multiple DcmDslConnections.
 */
	Dcm_DslConnectionType* DcmDslConnection ;
/* protocol. */
/* Enables /disables the endianness conversion, per diagnostic */
	boolean DcmDslProtocolEndiannessConvEnabled ;
/* Implementation Type: Dcm_ProtocolType */
	Dcm_DslProtocolIDType DcmDslProtocolID ;
/* Enables the parallel processing of ROE or Periodic Transmission protocol. Only these both protocols
 *  are allowed to run in parallel to normal protocol (UDS, OBD).
 */
	boolean DcmDslProtocolIsParallelExecutab ;
/* This is defined in the AUTOSAR SWS for DCM as a uint16.
 * 
 *                                                                 The AUTOSAR configuration standard
 *  is to use SI units, so this parameter is defined as a float value in seconds. DCM configuration
 *  tools must convert this float value to the appropriate value format for the use in the software
 *  implementation of DCM.
 * 
 *                                                                 min:
 *                                                                 A negative value is not allowed.
 * 
 *                                                                 upperMultiplicity:
 *                                                                 Exactly one DcmDslProtocolPreemptTimeout
 *  value per DSL protocol timing structure.
 * 
 *                                                                 lowerMultiplicity:
 *                                                                 Exactly one DcmDslProtocolPreemptTimeout
 *  value per DSL timing structure.
 * 
 *                                                                 origin:
 *                                                                 Standard AUTOSAR configuration
 *  parameter.
 */
/* This is the value for the timeout (in milliseconds) of preempting protocol until protocol needs
 *  to be started.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDslProtocolPreemptTimeout ;
/* 0 = Highest priority (protocol may not be preempted by other protocols)
 *                                                                 1, 2, 3... = Reducing priority.
 *  Protocol may be preempted by other protocols with lower priority value.
 * 
 *                                                                 upperMultiplicity:
 *                                                                 Exactly one priority must be
 *  provided per Tx Protocol.
 * 
 *                                                                 lowerMultiplicity:
 *                                                                 Exactly one priority must be
 *  provided per Tx Protocol.
 * 
 *                                                                 origin:
 *                                                                 Standard AUTOSAR configuration
 *  parameter.
 */
/* The SWS for DCM defines this item as uint8. This is the protocol priority that is used during
 *  protocol preemption handling.
 */
	uint8 DcmDslProtocolPriority ;
	Dcm_DslProtocolTransTypeType DcmDslProtocolTransType ;
/* Parameter specifying if the ECU should send a NRC 0x78 (response pending) before transitioning
 *  to the bootloader (parameter set to TRUE) or if the transition shall be initiated without sending
 *  NRC 0x78 (parameter set to FALSE).
 */
	boolean DcmSendRespPendOnTransToBoot ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as a float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value 
 *                                                                 format for the use in the software
 *  implementation of DCM.
 */
/* This parameter is used to gurantee that the DCM response is available on the bus before reaching
 *  P2.This parameter value in milliseconds has to be configured as a multiple of DcmTaskTime and
 *  is minimum in the timing handling of P2.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmTimStrP2ServerAdjust ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as a float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value 
 *                                                                 format for the use in the software
 *  implementation of DCM.
 */
/* This parameter is used to gurantee that the DCM response is available on the bus before reaching
 *  P2*.This parameter value in milliseconds has to be configured as multiple of DcmTaskTime and
 *  is minimum in the timing handling of P2*.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmTimStrP2StarServerAdjust ;
/* Link to buffer configuration (DcmDslBuffer) for configuration of protocol buffer used for Rx
 *  actions.
 */
/* upperMultiplicity / lowerMultiplicity::
 *                                                                 Exactly one Rx buffer is required
 *  for protocol reception
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsl/DcmDslBuffer */
	Dcm_DslBufferType* DcmDslProtocolRxBufferID ;
/* Link to the used diagnostic service table for this protocol. */
/* upperMultiplicity:
 *                                                                 Must have exactly one service
 *  table for the protocol.
 * 
 *                                                                 lowerMultiplicity:
 *                                                                 Must have exactly one service
 *  table for the protocol.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsd/DcmDsdServiceTable */
	Dcm_DsdServiceTableType* DcmDslProtocolSIDTable ;
/* Reference to the DcmDspSession table used for this protocol ConfigurationClass. */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession */
	Dcm_DspSessionType* DcmDslProtocolSessionRef ;
/* Link to buffer configuration (DcmDslBuffer) for configuration of protocol buffer used for Tx
 *  actions.
 */
/* upperMultiplicity / lowerMultiplicity::
 *                                                                 Exactly one Tx buffer is required
 *  for protocol transmission.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsl/DcmDslBuffer */
	Dcm_DslBufferType* DcmDslProtocolTxBufferID ;
} Dcm_DslProtocolRowType ;

/* This container contains the configuration (parameters) for the protocol configuration (for each
 *  protocol) The following parameters needs to be configured per protocol.
 */
typedef struct Dcm_DslProtocolType_tag
{
	Dcm_DslProtocolRowType* DcmDslProtocolRow ;
} Dcm_DslProtocolType ;

/* The name of this container is used to define the name of the R-Port through which the DCM accesses
 *  the interface ServiceRequestNotification.
 */
typedef struct Dcm_DslServiceRequestManufacturerNotificationType_tag
{
} Dcm_DslServiceRequestManufacturerNotificationType ;

/* The name of this container is used to define the name of the R-Port through which the DCM accesses
 *  the interface ServiceRequestNotification.
 */
typedef struct Dcm_DslServiceRequestSupplierNotificationType_tag
{
} Dcm_DslServiceRequestSupplierNotificationType ;

/* These parameters apply to a Diagnostic Session Layer. There may be a parameter set (DSL Configuration)
 *  per protocol.
 */
typedef struct Dcm_DslType_tag
{
	Dcm_DslBufferType* DcmDslBuffer ;
/* The R-Port is named CallbackDCMRequestServices_<SWC> where _<SWC> is the name of the container
 *  DcmDslCallbackDCMRequestService.
 */
	Dcm_DslCallbackDCMRequestServiceType* DcmDslCallbackDCMRequestService ;
	Dcm_DslDiagRespType* DcmDslDiagResp ;
	Dcm_DslProtocolType* DcmDslProtocol ;
/* The R-Port is named ServiceRequestManufacturerNotification_<SWC>;
 *                                                 where <SWC> is the name of the container DcmDslServiceRequestManufacturerNotification.
 * 
 *                                                 The  lowerMultiplicity is 0: If DcmRequestManufacturerNotificationEnabled
 *  = false the  Indication API is not available.
 */
	Dcm_DslServiceRequestManufacturerNotificationType* DcmDslServiceRequestManufacturerNotification ;
/* The R-Port is named ServiceRequestSupplierNotification_<SWC>
 *                                                 where <SWC> is the name of the container DcmDslServiceRequestSupplierNotification.
 * 
 *                                                 The  lowerMultiplicity is 0: If DcmRequestSupplierNotification
 *  = false the Indication API is not available.
 */
	Dcm_DslServiceRequestSupplierNotificationType* DcmDslServiceRequestSupplierNotification ;
} Dcm_DslType ;

/* Collection of ComM channels which shall be controlled if all networks are addressed. */
typedef struct Dcm_DspComControlAllChannelType_tag
{
/* Reference to ComM channel. */
/* /AUTOSAR/EcucDefs/ComM/ComMConfigSet/ComMChannel */
	ComM_ChannelType* DcmDspAllComMChannelRef ;
} Dcm_DspComControlAllChannelType ;

/* Provide the configuration of the Communication control. */
typedef struct Dcm_DspComControlSettingType_tag
{
/* Reference to DcmDspModeRule Mode rule which controls re-enabling */
/* of communication by DCM. 
 * 
 *                                                                 The DCM module shall call BswM_Dcm_CommunicationMode_CurrentState(DCM_ENABLE_RX_TX_NORM_NM))
 *  in case that the referenced mode rule is not fulfilled anymore.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspComControlCommunicationReEnableModeRuleRef ;
} Dcm_DspComControlSettingType ;

/* Assigns subnet number to ComM channel which will be controlled. */
typedef struct Dcm_DspComControlSpecificChannelType_tag
{
/* Subnet Number which controls the specific ComMChannel. */
	uint8 DcmDspSubnetNumber ;
/* Reference to ComM channel. */
/* /AUTOSAR/EcucDefs/ComM/ComMConfigSet/ComMChannel */
	ComM_ChannelType* DcmDspSpecificComMChannelRef ;
} Dcm_DspComControlSpecificChannelType ;

typedef struct Dcm_DspComControlType_tag
{
	Dcm_DspComControlAllChannelType* DcmDspComControlAllChannel ;
	Dcm_DspComControlSettingType* DcmDspComControlSetting ;
	Dcm_DspComControlSpecificChannelType* DcmDspComControlSpecificChannel ;
} Dcm_DspComControlType ;

/* Provide the configuration of the ControlDTCSetting mechanism. */
typedef struct Dcm_DspControlDTCSettingType_tag
{
/* Reference to DcmDspModeRule */
/* Mode rule which controls re-enabling of controlDTCsetting by DCM. The DCM module shall execute
 *  a ControlDTCSetting.Off  (call Dem_EnableDTCSetting()) in case that the referenced mode rule
 *  is not fulfilled anymore.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspControlDTCSettingReEnableModeRuleRef ;
} Dcm_DspControlDTCSettingType ;

/* Function name to demand application if the conditions (e.g. System state) to read the DID are
 *  correct. (ConditionCheckRead-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataConditionCheckReadFncType)(void);
 */

/* Function name to control the access to a certain ECU Signal by the DCM. (IoHwAb_Dcm_<EcuSignalName>-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataEcuSignalType)(void);
 */

/* Function name to request to application to freeze the current state of an IOControl. (FreezeCurrentState-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataFreezeCurrentStateFncType)(void);
 */

/* Function name to request to application the scaling information of the DID. (GetScalingInformation-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataGetScalingInfoFncType)(void);
 */

/* Function name to request from application the data length of a DID. (ReadDataLength-function). */
/* TODO: 
 * typedef void (*Dcm_DspDataReadDataLengthFncType)(void);
 */

/* Function name for read access to a certain ECU Signal by the DCM. (IoHwAb_Dcm_Read<EcuSignalName>-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataReadEcuSignalType)(void);
 */

/* Function name to request from application the data value of a DID. (ReadData-function). */
/* TODO: 
 * typedef void (*Dcm_DspDataReadFncType)(void);
 */

/* Function name to request to application to reset an IOControl to default value. (ResetToDefault-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataResetToDefaultFncType)(void);
 */

/* Function name to request to application to return control to ECU of an IOControl. (ReturnControlToECU-function).
 */
/* TODO: 
 * typedef void (*Dcm_DspDataReturnControlToEcuFncType)(void);
 */

/* Function name to request to application to adjuste the IO signal. (ShortTermAdjustment-function). */
/* TODO: 
 * typedef void (*Dcm_DspDataShortTermAdjustmentFncType)(void);
 */

/* Provide the data type of Data belonging to a DID. */
typedef enum
{
	DCM_DSPDATATYPE_BOOLEAN,
	DCM_DSPDATATYPE_SINT16,
	DCM_DSPDATATYPE_SINT32,
	DCM_DSPDATATYPE_SINT8,
	DCM_DSPDATATYPE_UINT16,
	DCM_DSPDATATYPE_UINT32,
	DCM_DSPDATATYPE_UINT8
} Dcm_DspDataTypeType ;

/* Define wich interface shall be used to access the data. */
typedef enum
{
	DCM_DSPDATAUSEPORT_USE_BLOCK_ID,
	DCM_DSPDATAUSEPORT_USE_DATA_ASYNCH_CLIENT_SERVER,
	DCM_DSPDATAUSEPORT_USE_DATA_ASYNCH_FNC,
	DCM_DSPDATAUSEPORT_USE_DATA_SENDER_RECEIVER,
	DCM_DSPDATAUSEPORT_USE_DATA_SYNCH_CLIENT_SERVER,
	DCM_DSPDATAUSEPORT_USE_DATA_SYNCH_FNC,
	DCM_DSPDATAUSEPORT_USE_ECU_SIGNAL
} Dcm_DspDataUsePortType ;

/* Function name to request application to write the data value of a DID. (WriteData-function). */
/* TODO: 
 * typedef void (*Dcm_DspDataWriteFncType)(void);
 */

/* This container contains the configuration (parameters) of a Data belonging to a DID */
typedef struct Dcm_DspDataType_tag
{
/* Multiplicity shall be equal to parameter DcmDspDataReadFnc.
 * 
 *                                                         Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC
 *  or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ConditionCheckRead.
 */
	Dcm_DspDataConditionCheckReadFncType DcmDspDataConditionCheckReadFnc ;
/* Only relevant if DcmDspDataUsePort==USE_ECU_SIGNAL. */
	Dcm_DspDataEcuSignalType DcmDspDataEcuSignal ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_FreezeCurrentState.
 */
	Dcm_DspDataFreezeCurrentStateFncType DcmDspDataFreezeCurrentStateFnc ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxxx_GetScalingInformation.
 */
	Dcm_DspDataGetScalingInfoFncType DcmDspDataGetScalingInfoFnc ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ReadDataLength.
 */
	Dcm_DspDataReadDataLengthFncType DcmDspDataReadDataLengthFnc ;
/* Only relevant if DcmDspDataUsePort==USE_ECU_SIGNAL. */
	Dcm_DspDataReadEcuSignalType DcmDspDataReadEcuSignal ;
/* Multiplicity shall be equal to parameter DcmDspDataConditionCheckReadFnc.
 * 
 *                                                         Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC
 *  or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ReadData.
 */
	Dcm_DspDataReadFncType DcmDspDataReadFnc ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ResetToDefault.
 */
	Dcm_DspDataResetToDefaultFncType DcmDspDataResetToDefaultFnc ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ReturnControlToECU.
 */
	Dcm_DspDataReturnControlToEcuFncType DcmDspDataReturnControlToEcuFnc ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_ShortTermAdjustment.
 */
	Dcm_DspDataShortTermAdjustmentFncType DcmDspDataShortTermAdjustmentFnc ;
/* Length of data in bits associated to the Data. If Data has variable datalength, that corresponds
 *  to the maximum datalength.
 */
	uint16 DcmDspDataSize ;
	Dcm_DspDataTypeType DcmDspDataType ;
	Dcm_DspDataUsePortType DcmDspDataUsePort ;
/* Only relevant if DcmDspDataUsePort=="USE_DATA_SYNCH_FNC or DcmDspDataUsePort==USE_DATA_ASYNCH_FNC".
 * 
 *                                                         This parameter is related to the interface
 *  Xxx_WriteData.
 */
	Dcm_DspDataWriteFncType DcmDspDataWriteFnc ;
/* Reference to 1 DcmDspDataInfo */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspDataInfo */
	Dcm_DspDataInfoType* DcmDspDataInfoRef ;
/* NRAM blockId to access the data. */
/* Only relevant if DcmDspDataUsePort==USE_BLOCK_ID. */
/* /AUTOSAR/EcucDefs/NvM/NvMBlockDescriptor */
	NvM_BlockDescriptorType* DcmDspDataBlockIdRef ;
} Dcm_DspDataType ;

/* This container contains the configuration (parameters) of a Data */
typedef struct Dcm_DspDataInfoType_tag
{
/* true = datalength of the Data is fixed
 *                                                         false = datalength of the Data is variable
 */
/* Indicates if the datalength of the Data is fixed */
	boolean DcmDspDataFixedLength ;
/* If Scaling information service is available for this Data, it provides the size of the scaling
 *  information.
 */
	uint32 DcmDspDataScalingInfoSize ;
} Dcm_DspDataInfoType ;

/* Function name to activate/deactivate an ROE event managed externally. Only relevant if DcmDspDataUsePort==
 *  USE_DATA_SYNCH_FNC or USE_DATA_ASYNCH_FNC. This parameter is related to the interface xxx_ActivateEvent.
 */
/* TODO: 
 * typedef void (*Dcm_DspDidRoeActivateFncType)(void);
 */

/* Provide information to manage a responseOnEvent  request on this DID externally. If this container
 *  doesn't exist, an ROE event on this DID will be managed internally.
 */
typedef struct Dcm_DspDidExtRoeType_tag
{
	Dcm_DspDidRoeActivateFncType DcmDspDidRoeActivateFnc ;
/* EventId to be used within Apis  Dcm_TriggerOnEvent() and xxx_ActivateEvent() */
	uint8 DcmDspDidRoeEventId ;
} Dcm_DspDidExtRoeType ;

/* This container defines the reference to 1 DcmDspData container and position relevant for this DID. */
typedef struct Dcm_DspDidSignalType_tag
{
/* The position is defined in bits. */
/* Defines the position of the data defined by DcmDspDidDataRef reference to DcmDspData container
 *  in the DID.
 */
	uint16 DcmDspDidDataPos ;
/* Reference to 1 DcmDspData container relevant for this DID. */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspData */
	Dcm_DspDataType* DcmDspDidDataRef ;
} Dcm_DspDidSignalType ;

/* This container contains the configuration (parameters) of the DID. */
typedef struct Dcm_DspDidType_tag
{
	Dcm_DspDidExtRoeType* DcmDspDidExtRoe ;
	Dcm_DspDidSignalType* DcmDspDidSignal ;
/* 2 byte Identifier of the DID */
	uint16 DcmDspDidIdentifier ;
/* If set to FALSE, the ROE event will be sent without queuing. */
/* If set to TRUE, the ROE queue mechanism will be used in case of ROE OnChangeOfDataIdentifier
 *  on this DID.
 */
	boolean DcmDspDidRoeQueueEnabled ;
/* true = DID available
 *                                                         false = DID not available
 */
/* Allow to activate or deactivate the usage of a DID, for multi  purpose ECUs */
	boolean DcmDspDidUsed ;
/* Reference to DcmDspDidInfo containing information on this DID. */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspDidInfo */
	Dcm_DspDidInfoType* DcmDspDidInfoRef ;
/* Reference to DcmDspDid in case this DID refer to one or serveral other DID's */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspDid */
	Dcm_DspDidType* DcmDspDidRef ;
} Dcm_DspDidType ;

/* This container contains the configuration (parameters) of the DID control. */
typedef struct Dcm_DspDidControlType_tag
{
/* <b>This indicates the presence of "FreezeCurrentState".</b> */
	boolean DcmDspDidFreezeCurrentState ;
/* <b>This indicates the presence of "ResetToDefault".</b> */
	boolean DcmDspDidResetToDefault ;
/* <b>This indicates the presence of "ReturnControlToEcu".</b> */
	boolean DcmDspDidReturnControlToEcu ;
/* This indicates the presence of "ShortTermAdjustment". */
	boolean DcmDspDidShortTermAdjustment ;
/* Reference to DcmDspModeRule */
/* Mode rule which controls this DID. If there is no reference, no check of the mode rule shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspDidControlModeRuleRef ;
/* Reference to DcmDspSecurityRow */
/* Security levels allowed to control this DID. If there is no reference, no check of security
 *  level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspDidControlSecurityLevelRef ;
/* Reference to DcmDspSessionRow */
/* Sessions allowed to control this DID. If there is no reference, no check of session level shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDspDidControlSessionRef ;
} Dcm_DspDidControlType ;

/* This container contains the configuration (parameters) of the DID read. */
typedef struct Dcm_DspDidReadType_tag
{
/* Reference to DcmDspModeRule */
/* Mode rule which controls to read this DID. If there is no reference, no check of the mode rule
 *  shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspDidReadModeRuleRef ;
/* Reference to DcmDspSecurityRow */
/* Security levels allowed to read this DID. If there is no reference, no check of security level
 *  shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspDidReadSecurityLevelRef ;
/* Reference to DcmDspSessionRow */
/* Sessions allowed to read this DID. If there is no reference, no check of session level shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDspDidReadSessionRef ;
} Dcm_DspDidReadType ;

/* This container contains the configuration (parameters) of the DID write. */
typedef struct Dcm_DspDidWriteType_tag
{
/* Reference to DcmDspModeRule */
/* Mode rule which controls to write this DID. If there is no reference, no check of the mode rule
 *  shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspDidWriteModeRuleRef ;
/* Reference to DcmDspSecurityRow */
/* Security levels allowed to write this DID. If there is no reference, no check of security level
 *  shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspDidWriteSecurityLevelRef ;
/* Reference to DcmDspSessionRow */
/* Sessions allowed to write this DID. If there is no reference, no check of session level shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDspDidWriteSessionRef ;
} Dcm_DspDidWriteType ;

/* This container contains the configuration (parameters) of the DID access */
typedef struct Dcm_DspDidAccessType_tag
{
	Dcm_DspDidControlType* DcmDspDidControl ;
	Dcm_DspDidReadType* DcmDspDidRead ;
	Dcm_DspDidWriteType* DcmDspDidWrite ;
} Dcm_DspDidAccessType ;

/* This container contains the configuration (parameters) of the DID's Info */
typedef struct Dcm_DspDidInfoType_tag
{
	Dcm_DspDidAccessType* DcmDspDidAccess ;
/* true = DID can be dynamically defined
 *                                                         false = DID can not be dynamically defined
 */
/* Indicates if this DID can be dynamically defined */
	boolean DcmDspDidDynamicallyDefined ;
} Dcm_DspDidInfoType ;

/* Function name to request from application if a specific DID is available within the range or not. */
/* TODO: 
 * typedef void (*Dcm_DspDidRangeIsDidAvailableFncType)(void);
 */

/* Function name to request from application the data range value of a DID.(ReadData-function). */
/* TODO: 
 * typedef void (*Dcm_DspDidRangeReadDidFncType)(void);
 */

/* Function name to request application to write the data range value of a DID.(WriteData-function). */
/* TODO: 
 * typedef void (*Dcm_DspDidRangeWriteDidFncType)(void);
 */

/* This container defines the DID Range */
typedef struct Dcm_DspDidRangeType_tag
{
/* Parameter specifying if there are gaps in the DID range (parameter set to TRUE) or not (parameter
 *  set to FALSE)
 */
	boolean DcmDspDidRangeHasGaps ;
/* Lower limit of DID range. */
	uint16 DcmDspDidRangeIdentifierLowerLimit ;
/* Upper limit of DID range. */
	uint16 DcmDspDidRangeIdentifierUpperLimit ;
/* Only relevant if DcmDspDidRangeUsePort is set to false. This parameter is related to the interface
 *  Xxx_IsDidAvailable.
 */
	Dcm_DspDidRangeIsDidAvailableFncType DcmDspDidRangeIsDidAvailableFnc ;
/* Maximum data length in bytes */
	uint16 DcmDspDidRangeMaxDataLength ;
/* Only relevant if DcmDspDidRangeUsePort is set to false. This parameter is related to the interface
 *  Xxx_ReadDidData.
 */
	Dcm_DspDidRangeReadDidFncType DcmDspDidRangeReadDidFnc ;
/* When the parameter DcmDspDidRangeUsePort is set to true the DCM will access the Data using an
 *  R-Port requiring a PortInteface DataServices_DIDRange. In that case, DcmDspDidRangeIsDidAvailableFnc,
 *  DcmDspDidRangeReadDidFnc and DcmDspDidRangeWriteDidFnc are ignored and the RTE APIs are used.
 *  When the parameter DcmDspDidRangeUsePort is false, the DCM calls the functions defined in DcmDspDidRangeIsDidAvailableFnc,
 *  DcmDspDidRangeReadDidFnc and DcmDspDidRangeWriteDidFnc.
 */
	boolean DcmDspDidRangeUsePort ;
/* Only relevant if DcmDspDidRangeUsePort is set to false. This parameter is related to the interface
 *  Xxx_WriteDidData.
 */
	Dcm_DspDidRangeWriteDidFncType DcmDspDidRangeWriteDidFnc ;
/* Reference to DcmDspDidInfo containing information on this DID Range. */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspDidInfo */
	Dcm_DspDidInfoType* DcmDspDidRangeInfoRef ;
} Dcm_DspDidRangeType ;

/* Provides the range of memory address allowed for reading */
typedef struct Dcm_DspReadMemoryRangeInfoType_tag
{
/* High memory address of a range allowed for reading */
	uint32 DcmDspReadMemoryRangeHigh ;
/* Low memory address of a range allowed for reading */
	uint32 DcmDspReadMemoryRangeLow ;
/* Reference to DcmDspModeRule */
/* Mode rule which controls read  access on this memory address. If there is no reference, no check
 *  of the mode rule shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspReadMemoryRangeModeRuleRef ;
/* Link to the Security Access Levels needed for read  access on this memory address. If there
 *  is no reference, no check of security level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspReadMemoryRangeSecurityLevelRef ;
} Dcm_DspReadMemoryRangeInfoType ;

/* Provides the range of memory address allowed for writting. */
typedef struct Dcm_DspWriteMemoryRangeInfoType_tag
{
/* High memory address of a range allowed for writting. */
	uint32 DcmDspWriteMemoryRangeHigh ;
/* Low memory address of a range allowed for writting */
	uint32 DcmDspWriteMemoryRangeLow ;
/* Reference to DcmDspModeRule */
/* Mode rule which controls write access on this memory address. If there is no reference, no check
 *  of the mode rule shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspWriteMemoryRangeModeRuleRef ;
/* Link to the Security Access Levels needed for write  access on this memory address. If there
 *  is no reference, no check of security level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspWriteMemoryRangeSecurityLevelRef ;
} Dcm_DspWriteMemoryRangeInfoType ;

/* Provides the value of memory identifier used to select the desired memory device */
typedef struct Dcm_DspMemoryIdInfoType_tag
{
	Dcm_DspReadMemoryRangeInfoType* DcmDspReadMemoryRangeInfo ;
	Dcm_DspWriteMemoryRangeInfoType* DcmDspWriteMemoryRangeInfo ;
/* Value of the memory device identifer used. This parameter is only relevant if the memory Id
 *  parameter use is enabled. (DcmDspUseMemoryId = TRUE)
 */
	uint8 DcmDspMemoryIdValue ;
} Dcm_DspMemoryIdInfoType ;

/* This container contains the configuration of the memory access. */
typedef struct Dcm_DspMemoryType_tag
{
/* This container contains the configuration of the memory access  requested through diagnostic
 *  services : ReadMemoryByAddress,  WriteMemoryByAddress, RequestDownload, RequestUpload
 */
	Dcm_DspMemoryIdInfoType* DcmDspMemoryIdInfo ;
/* The Dcm_WriteMemory and Dcm_ReadMemory callouts shall be called without the MemoryIdentifier
 *  parameter. If this parameter is set to true, the DCM will use MemoryIdentifier parameter to
 *  select the memory device to use. The Dcm_WriteMemory and Dcm_ReadMemory callouts shall be called
 *  with the MemoryIdentifier parameter.
 */
/* If this parameter is set to false, the DCM will not use MemoryIdentifier parameter. */
	boolean DcmDspUseMemoryId ;
} Dcm_DspMemoryType ;

/* This container defines the supported information. */
typedef struct Dcm_DspPidDataSupportInfoType_tag
{
/* referenced Bit of the SupportInfo */
	uint8 DcmDspPidDataSupportInfoBit ;
/* Reference to DcmDspPidSupportInfo */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspPid/DcmDspPidSupportInfo */
	Dcm_DspPidSupportInfoType* DcmDspPidDataSupportInfoRef ;
} Dcm_DspPidDataSupportInfoType ;

/* Function name for reading PID data value. */
/* TODO: 
 * typedef void (*Dcm_DspPidDataReadFncType)(void);
 */

/* If this parameter is set to USE_DATA_SYNCH_FNC, the DCM will use the function defined in DcmDspPidDataReadFnc
 *  to get the PID data value.
 */
typedef enum
{
	DCM_DSPPIDDATAUSEPORT_USE_DATA_SENDER_RECEIVER,
	DCM_DSPPIDDATAUSEPORT_USE_DATA_SYNCH_CLIENT_SERVER,
	DCM_DSPPIDDATAUSEPORT_USE_DATA_SYNCH_FNC
} Dcm_DspPidDataUsePortType ;

/* Contains specific configuration parameter of PID for service $01. This container exists only
 *  if DcmDspPidService is set to DCM_SERVICE_01 or DCM_SERVICE_01_02.
 */
typedef struct Dcm_DspPidService01Type_tag
{
/* This is only relevant if DcmDspPidDataUsePort==USE_DATA_SYNCH_FNC.
 * 
 *                                                                         This parameter is related
 *  to the interface Xxx_ReadData.
 */
	Dcm_DspPidDataReadFncType DcmDspPidDataReadFnc ;
/* If this parameter is set to USE_DATA_SYNCH_CLIENT_SERVER, the DCM will have an R-Port requiring
 *  the interface DataServices_<Data>. 
 * 
 *                                                                         If this parameter is
 *  set to USE_DATA_SENDER_RECEIVER, the DCM will have an R-Port requiring a SenderReceiverInterface
 * 
 *                                                                         The R-Port is named
 *  DataServices_<Data> where <Data> is the name of the container DcmDspPidData.
 */
	Dcm_DspPidDataUsePortType DcmDspPidDataUsePort ;
} Dcm_DspPidService01Type ;

/* Contains specific configuration parameter of PID for service $02. This container exists only
 *  if DcmDspPidService is set to DCM_SERVICE_02 or DCM_SERVICE_01_02.
 */
typedef struct Dcm_DspPidService02Type_tag
{
/* Reference to DemPidDataElement in DEM configuration. Allows to link the DCM PID and DEM PID
 *  configuration for Mode $02.
 */
/* /AUTOSAR/EcucDefs/Dem/DemConfigSet/DemPidClass/DemPidDataElement */
	Dem_PidDataElementType* DcmDspPidDataDemRef ;
} Dcm_DspPidService02Type ;

/* This container defines the parameter for a Signal in the PID. */
typedef struct Dcm_DspPidDataType_tag
{
	Dcm_DspPidDataSupportInfoType* DcmDspPidDataSupportInfo ;
	Dcm_DspPidService01Type* DcmDspPidService01 ;
	Dcm_DspPidService02Type* DcmDspPidService02 ;
/* This is the position in bit of the PID structure and will not start at position 0 in case a
 *  support information is availabe (for bit-mapped PIDs).
 */
	uint16 DcmDspPidDataPos ;
/* Length of data associated to the PID in bit. */
	uint16 DcmDspPidDataSize ;
} Dcm_DspPidDataType ;

/* This container defines the support information (typically byte A) to declare the usability of
 *  the data bytes within the so-called bit-mapped PIDs (e.g. PID$68).
 */
typedef struct Dcm_DspPidSupportInfoType_tag
{
/* Length of the supported information in bytes. */
	uint8 DcmDspPidSupportInfoLen ;
/* Position of the supported information in bytes. */
	uint8 DcmDspPidSupportInfoPos ;
} Dcm_DspPidSupportInfoType ;

/* Allow to indicate if this PID is used for service $01 or/and $02. */
typedef enum
{
	DCM_SERVICE_01,
	DCM_SERVICE_01_02,
	DCM_SERVICE_02
} Dcm_DspPidServiceType ;

/* This container defines the availability of a PID to the DCM. */
typedef struct Dcm_DspPidType_tag
{
	Dcm_DspPidDataType* DcmDspPidData ;
	Dcm_DspPidSupportInfoType* DcmDspPidSupportInfo ;
/* 1 byte Identifier of the PID */
	uint8 DcmDspPidIdentifier ;
	Dcm_DspPidServiceType DcmDspPidService ;
/* Length of the PID in byte. */
	uint8 DcmDspPidSize ;
/* true = PID available
 *                                                         false = PID not available
 */
/* Allow to activate or deactivate the usage of a PID, for multi  purpose ECUs */
	boolean DcmDspPidUsed ;
} Dcm_DspPidType ;

/* This container contains the configuration (parameters) of the "Request control of on-board system,
 *  test or component" service (Service $08).
 */
typedef struct Dcm_DspRequestControlType_tag
{
	uint32 DcmDspRequestControlInBufferSize ;
	uint32 DcmDspRequestControlOutBufferSize ;
/* Test Id for Service $08 */
	uint8 DcmDspRequestControlTestId ;
} Dcm_DspRequestControlType ;

/* Function name to initialize an ROE event managed externally. */
/* TODO: 
 * typedef void (*Dcm_DspRoeInitFncType)(void);
 */

/* Function name to stop an ROE event managed externally. */
/* TODO: 
 * typedef void (*Dcm_DspRoeStopFncType)(void);
 */

/* Provide the configuration of the ResponseOnEvent mechanism. */
typedef struct Dcm_DspRoeType_tag
{
/* Size of the buffer used to managed internally the subservice OnChangeOfDataIdentifier of ResponseOnEvent
 *  Service.
 */
	uint16 DcmDspRoeBufSize ;
	Dcm_DspRoeInitFncType DcmDspRoeInitFnc ;
/* If set to TRUE the ROE functionality is re-initialized on reception of service DiagnosticSessionControl.
 */
	boolean DcmDspRoeInitOnDSC ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value format for the use in the software implementation of DCM.
 * 
 *                                                         min:
 *                                                         A negative value is not allowed.
 */
/* Provide the minimum time in ms between two transmissions of ROE event. It is used for the delay
 *  between two different consecutive Roe transmissions and between two transmissions of the retry
 *  mechanism.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDspRoeInterMessageTime ;
/* Provide the max size in byte of an ROE message that will be stored in the ROE transmission queue. */
	uint16 DcmDspRoeMaxEventLength ;
/* If set to 0, no retry mechanism will be managed */
/* Provide the max number of re-transmission of an ROE event in case of transmission failure. */
	uint8 DcmDspRoeMaxNumberOfRetry ;
/* Provide the max number of element in the ROE transmission queue. */
	uint16 DcmDspRoeMaxQueueLength ;
/* If set to FALSE, the ROE event will be sent without queuing. */
/* If set to TRUE, the ROE queue mechanism is enabled on DCM. */
	boolean DcmDspRoeQueueEnabled ;
	Dcm_DspRoeStopFncType DcmDspRoeStopFnc ;
} Dcm_DspRoeType ;

/* Function name for request to application the results of a routine. (Routine_RequestResults-function)
 */
/* TODO: 
 * typedef void (*Dcm_DspRequestResultsRoutineFncType)(void);
 */

/* Function name for request to application to start a routine. (Routine_Start-function) */
/* TODO: 
 * typedef void (*Dcm_DspStartRoutineFncType)(void);
 */

/* Function name for request to application to stop a routine. (Routine_Stop-function) */
/* TODO: 
 * typedef void (*Dcm_DspStopRoutineFncType)(void);
 */

/* This container contains the configuration (parameters) for Routines */
typedef struct Dcm_DspRoutineType_tag
{
/* This parameter is related to the interface Xxx_RequestResults. */
	Dcm_DspRequestResultsRoutineFncType DcmDspRequestResultsRoutineFnc ;
/* true = requestRoutineResults is supported
 *                                                         false = requestRoutineResults is not
 *  supported
 */
/* Indicates if the optional requestRoutineResults in the RoutineControl is supported */
	boolean DcmDspRequestResultsRoutineSupported ;
/* true = datalength of the optional record is  fixed 
 *                                                         false = datalength of the optional record
 *  is variable
 * 
 *                                                         In case DcmDspRoutineFixedLength is
 *  set to FALSE, the
 *                                                         DcmDspRoutineSignalLength for the last
 *  signal is the maximum length (in bits)
 *                                                         of the optional record.
 */
/* Indicates if the datalength of the optional record in the RoutineControl request and response
 *  is fixed.
 */
	boolean DcmDspRoutineFixedLength ;
/* 2 bytes Identifier of the RID */
	uint16 DcmDspRoutineIdentifier ;
/* The R-Port is named RoutineServices_<ROUTINENAME> 
 *                                                         where <ROUTINENAME> is the name of the
 *  container DcmDspRoutine
 *                                                         In that case, the configuration must
 *  not provide function names in DcmDspStartRoutineFnc, DcmDspStopRoutineFnc or DcmDspRequestResultsRoutineFnc.
 *                                                         If this is false, the DCM expects to
 *  find the names of the functions to be used in DcmDspStartRoutineFnc, DcmDspStopRoutineFnc or
 *  DcmDspRequestResultsRoutineFnc.
 */
/* If this parameter is set to true, the DCM uses a port requiring a PortInterface RoutineServices_<ROUTINENAME>.
 */
	boolean DcmDspRoutineUsePort ;
/* true = Routine available
 *                                                         false = Routine not available
 */
/* Allow to activate or deactivate the usage of a Routine, for multi  purpose ECUs */
	boolean DcmDspRoutineUsed ;
/* This parameter is related to the interface Xxx_Start. */
	Dcm_DspStartRoutineFncType DcmDspStartRoutineFnc ;
/* This parameter is related to the interface Xxx_Stop. */
	Dcm_DspStopRoutineFncType DcmDspStopRoutineFnc ;
/* true = stopRoutine is supported
 *                                                         false = stopRoutine is not supported
 */
/* Indicates if the optional stopRoutine in the RoutineControl is supported */
	boolean DcmDspStopRoutineSupported ;
/* Reference to DcmDspRoutineInfo containing information on this routine. */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspRoutineInfo */
	Dcm_DspRoutineInfoType* DcmDspRoutineInfoRef ;
} Dcm_DspRoutineType ;

/* This container contains the configuration (parameters) for the Routine Authorization. */
typedef struct Dcm_DspRoutineAuthorizationType_tag
{
/* Reference to DcmDspModeRule */
/* Mode rule which controls this RID. If there is no reference, no check of the mode rule shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
	Dcm_ModeRuleType* DcmDspRoutineModeRuleRef ;
/* Reference to DcmDspSecurityRow */
/* Security levels allowed to control this RID. If there is no reference, no check of security
 *  level shall be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSecurity/DcmDspSecurityRow */
	Dcm_DspSecurityRowType* DcmDspRoutineSecurityLevelRef ;
/* Reference to DcmDspSessionRow */
/* Sessions allowed to control this RID. If there is no reference, no check of session level shall
 *  be done.
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspSession/DcmDspSessionRow */
	Dcm_DspSessionRowType* DcmDspRoutineSessionRef ;
} Dcm_DspRoutineAuthorizationType ;

/* Provide the type of the signal in the RoutineControl request/response. */
typedef enum
{
	DCM_DSPROUTINESIGNALTYPE_BOOLEAN,
	DCM_DSPROUTINESIGNALTYPE_SINT16,
	DCM_DSPROUTINESIGNALTYPE_SINT32,
	DCM_DSPROUTINESIGNALTYPE_SINT8,
	DCM_DSPROUTINESIGNALTYPE_UINT16,
	DCM_DSPROUTINESIGNALTYPE_UINT32,
	DCM_DSPROUTINESIGNALTYPE_UINT8,
	DCM_DSPROUTINESIGNALTYPE_VARIABLE_LENGTH
} Dcm_DspRoutineSignalTypeType ;

/* Provide description of a routine signal used in RoutineControl service. */
typedef struct Dcm_DspRoutineRequestResOutSignalType_tag
{
/* Provide the length in bits of the signal in the RoutineControl request/response */
	uint16 DcmDspRoutineSignalLength ;
/* The position is defined in bits. */
/* Provide the position of the signal in the RoutineControl request/response. */
	uint16 DcmDspRoutineSignalPos ;
	Dcm_DspRoutineSignalTypeType DcmDspRoutineSignalType ;
} Dcm_DspRoutineRequestResOutSignalType ;

/* Provide description of output parameter of RequestResult subservice for RoutineControl service. */
typedef struct Dcm_DspRoutineRequestResOutType_tag
{
	Dcm_DspRoutineRequestResOutSignalType* DcmDspRoutineRequestResOutSignal ;
} Dcm_DspRoutineRequestResOutType ;

/* Provide description of a routine signal used in RoutineControl service. */
typedef struct Dcm_DspRoutineStopInSignalType_tag
{
	uint16 DcmDspRoutineSignalLength ;
/* The position is defined in bits. */
	uint16 DcmDspRoutineSignalPos ;
	Dcm_DspRoutineSignalTypeType DcmDspRoutineSignalType ;
} Dcm_DspRoutineStopInSignalType ;

/* Provide description of input parameter of Stop subservice for RoutineControl service. */
typedef struct Dcm_DspRoutineStopInType_tag
{
	Dcm_DspRoutineStopInSignalType* DcmDspRoutineStopInSignal ;
} Dcm_DspRoutineStopInType ;

/* Provide description of a routine signal used in RoutineControl service. */
typedef struct Dcm_DspRoutineStopOutSignalType_tag
{
	uint16 DcmDspRoutineSignalLength ;
/* The position is defined in bits. */
	uint16 DcmDspRoutineSignalPos ;
	Dcm_DspRoutineSignalTypeType DcmDspRoutineSignalType ;
} Dcm_DspRoutineStopOutSignalType ;

/* Provide description of output parameter of Stop subservice for RoutineControl service. */
typedef struct Dcm_DspRoutineStopOutType_tag
{
	Dcm_DspRoutineStopOutSignalType* DcmDspRoutineStopOutSignal ;
} Dcm_DspRoutineStopOutType ;

/* Provide description of a routine signal used in RoutineControl service. */
typedef struct Dcm_DspStartRoutineInSignalType_tag
{
	uint16 DcmDspRoutineSignalLength ;
/* The position is defined in bits. */
	uint16 DcmDspRoutineSignalPos ;
	Dcm_DspRoutineSignalTypeType DcmDspRoutineSignalType ;
} Dcm_DspStartRoutineInSignalType ;

/* Provide description of input parameter of Start subservice for RoutineControl service */
typedef struct Dcm_DspStartRoutineInType_tag
{
	Dcm_DspStartRoutineInSignalType* DcmDspStartRoutineInSignal ;
} Dcm_DspStartRoutineInType ;

/* Provide description of a routine signal used in RoutineControl service. */
typedef struct Dcm_DspStartRoutineOutSignalType_tag
{
	uint16 DcmDspRoutineSignalLength ;
/* The position is defined in bits. */
	uint16 DcmDspRoutineSignalPos ;
	Dcm_DspRoutineSignalTypeType DcmDspRoutineSignalType ;
} Dcm_DspStartRoutineOutSignalType ;

/* Provide description of output parameter of Start subservice for RoutineControl service. */
typedef struct Dcm_DspStartRoutineOutType_tag
{
	Dcm_DspStartRoutineOutSignalType* DcmDspStartRoutineOutSignal ;
} Dcm_DspStartRoutineOutType ;

/* This container contains the configuration (parameters) for Routine's Info. */
typedef struct Dcm_DspRoutineInfoType_tag
{
	Dcm_DspRoutineAuthorizationType* DcmDspRoutineAuthorization ;
	Dcm_DspRoutineRequestResOutType* DcmDspRoutineRequestResOut ;
	Dcm_DspRoutineStopInType* DcmDspRoutineStopIn ;
	Dcm_DspRoutineStopOutType* DcmDspRoutineStopOut ;
	Dcm_DspStartRoutineInType* DcmDspStartRoutineIn ;
	Dcm_DspStartRoutineOutType* DcmDspStartRoutineOut ;
} Dcm_DspRoutineInfoType ;

/* Definition of a single Row of configuration for security level configuration (per security level) */
typedef struct Dcm_DspSecurityRowType_tag
{
/* Size of the AccessDataRecord used in GetSeed */
	uint32 DcmDspSecurityADRSize ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value format for the use in the software implementation of DCM.
 * 
 *                                                                 min:
 *                                                                 A negative value is not allowed.
 * 
 *                                                                 upperMultiplicity:
 *                                                                 Exactly one delay time must
 *  be specified per security levbel configuration.
 * 
 *                                                                 lowerMultiplicity:
 *                                                                 Exactly one delay time must
 *  be specified per security levbel configuration.
 * 
 *                                                                 origin:
 *                                                                 Standard AUTOSAR configuration
 *  parameter.
 */
/* Delay time after failed security access (in ms). This is started after DcmDspSecurityNumAttDelay
 *  number of failed security accesses.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDspSecurityDelayTime ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value format for the use in the software implementation of DCM.
 * 
 *                                                                 min:
 *                                                                 A negative value is not allowed.
 * 
 *                                                                 upperMultiplicity:
 *                                                                 Exactly one delay time must
 *  be specified per security level configuration.
 * 
 *                                                                 lowerMultiplicity:
 *                                                                 Exactly one delay time must
 *  be specified per security level configuration.
 */
/* Start delay timer on power on (in ms) */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDspSecurityDelayTimeOnBoot ;
/* size of the security key (in Bytes). */
	uint32 DcmDspSecurityKeySize ;
/* Level 1 is the highest security level. The locked state cannot be configured explicitly.
 * 
 *                                                                 1,2,3...63:
 *                                                                 configuration dependent - Conversion
 *  formula to calculate SecurityLevel out of tester requested 
 * 
 *                                                                 SecurityAccessType parameter:
 *                                                                 SecurityLevel = (SecurityAccessType
 *  + 1) / 2
 * 
 *                                                                 Type: Dcm_SecLevelType
 */
/* Value of Security level. */
	uint8 DcmDspSecurityLevel ;
/* Number of failed security accesses after which the delay time is activated */
	uint8 DcmDspSecurityNumAttDelay ;
/* size of the security seed (in Bytes). */
	uint32 DcmDspSecuritySeedSize ;
} Dcm_DspSecurityRowType ;

/* This container contains the configuration ( DSP parameter) for security level configuration
 *  (per security level)
 */
typedef struct Dcm_DspSecurityType_tag
{
/* The name of this container is used to define the name of the R-Port through which the DCM accesses
 *  the interface SecurityAccess_<LEVEL>.
 *                                                         The R-Port is named SecurityAccess_<LEVEL>
 *  where _<LEVEL> is the name of the container DcmDspSecurityRow. If there is no reference, no
 *  check of security level shall be done.
 */
	Dcm_DspSecurityRowType* DcmDspSecurityRow ;
} Dcm_DspSecurityType ;

/* This parameter defines whether this diagnostic session allows to jump to Bootloader (OEM Bootloader
 *  or System Supplier Bootloader). If this diagnostic session doesn't allow to jump to Bootloader
 *  the value DCM_NO_BOOT shall be chosen.
 */
typedef enum
{
	DCM_NO_BOOT,
	DCM_OEM_BOOT,
	DCM_SYS_BOOT
} Dcm_DspSessionForBootType ;

/* Definition of a single Row of session control configuration (per session control) */
typedef struct Dcm_DspSessionRowType_tag
{
	Dcm_DspSessionForBootType DcmDspSessionForBoot ;
/* SWS defines the Dcm_SesCtrlType:
 *                                                                 1 DEFAULT_SESSION
 *                                                                 2 PROGRAMMING_SESSION
 *                                                                 3 EXTENDED_DIAGNOSTIC_SESSION
 *                                                                 4 SAFETY_SYSTEM_DIAGNOSTIC_SESSION
 *                                                                 5...63 Reserved by Document
 *                                                                 64...126 <configuration dependent
 *  (according "diagnosticSessionType" parameter DiagnosticSessionControl request>
 *                                                                 127...254 Reserved by Document
 *                                                                 255 ALL_SESSION_LEVEL
 */
/* Value of the Session control. The symbolicName represents the Name of the Session */
	uint8 DcmDspSessionLevel ;
/* This is defined in the AUTOSAR SWS for DCM as a uint16.
 * 
 *                                                                 The AUTOSAR configuration standard
 *  is to use SI units, so this parameter is defined as a float value in seconds. DCM configuration
 *  tools must convert this float value to the appropriate value format for the use in the software
 *  implementation of DCM.
 */
/* This is the session value for P2ServerMax in milliseconds (per Session Control). */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDspSessionP2ServerMax ;
/* This is defined in the AUTOSAR SWS for DCM as a uint16.
 * 
 *                                                                 The AUTOSAR configuration standard
 *  is to use SI units, so this parameter is defined as a float value in seconds. DCM configuration
 *  tools must convert this float value to the appropriate value format for the use in the software
 *  implementation of DCM.
 */
/* This is the session value for P2*ServerMax in milliseconds (per Session Control). */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmDspSessionP2StarServerMax ;
} Dcm_DspSessionRowType ;

/* This container contains the configuration ( DSP parameter) session control configuration (per
 *  session control)
 */
typedef struct Dcm_DspSessionType_tag
{
	Dcm_DspSessionRowType* DcmDspSessionRow ;
} Dcm_DspSessionType ;

/* This container contains the configuration (parameters) of the TIDs belonging to the OBDMID for
 *  the "Request on-board monitoring test results" service (Service $06).
 */
typedef struct Dcm_DspTestResultObdmidTidsType_tag
{
/* Unit And Scaling ID for Service $06 */
	uint8 DcmDspTestResultObdmidTidUaSid ;
/* Link to reported TIDs of this OBDMID */
/* upperMultiplicity / lowerMultiplicity::
 *                                                                         At least one TID must
 *  be reported for an OBDMID
 */
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmDsp/DcmDspTestResultByObdmid/DcmDspTestResultTid */
	Dcm_DspTestResultTidType* DcmDspTestResultObdmidTidRef ;
} Dcm_DspTestResultObdmidTidsType ;

/* This container contains the configuration (parameters) of a OBDMID and the assigned TIDs for
 *  the "Request on-board monitoring test results" service (Service $06).
 */
typedef struct Dcm_DspTestResultObdmidTidType_tag
{
	Dcm_DspTestResultObdmidTidsType* DcmDspTestResultObdmidTids ;
/* OBDMID for Service $06 */
	uint8 DcmDspTestResultObdmid ;
} Dcm_DspTestResultObdmidTidType ;

/* This container contains the configuration (parameters) of a single TID for the "Request on-board
 *  monitoring test results" service (Service $06).
 */
typedef struct Dcm_DspTestResultTidType_tag
{
/* Test Id for Service $06 */
	uint8 DcmDspTestResultTestId ;
} Dcm_DspTestResultTidType ;

/* This container contains the configuration (parameters) of the "Request on-board monitoring test
 *  results" service (Service $06).
 */
typedef struct Dcm_DspTestResultByObdmidType_tag
{
	Dcm_DspTestResultObdmidTidType* DcmDspTestResultObdmidTid ;
/* The DCM will access the Data using an R-Port requiring a PortInterface DTRServices.
 *                                                         The R-Port is named DtrServices_<OBDMID>_<TID>
 *  where <TID> is the name of the container DcmDspTestResultTid and <OBDMID> is the name of the
 *  container DcmDspTestResultObdmidTid.
 */
	Dcm_DspTestResultTidType* DcmDspTestResultTid ;
} Dcm_DspTestResultByObdmidType ;

/* Function name for reading InfoType data item. */
/* TODO: 
 * typedef void (*Dcm_DspVehInfoDataReadFncType)(void);
 */

/* Data Item of an InfoType; post-fix of the port interface name. */
typedef struct Dcm_DspVehInfoDataType_tag
{
/* The configuration of order needs to be unique per InfoType. */
/* Defines the order of the data item in the InfoType; values: 0..255; first data item having the
 *  order number 0; the next 1 and so on.
 */
	uint8 DcmDspVehInfoDataOrder ;
	Dcm_DspVehInfoDataReadFncType DcmDspVehInfoDataReadFnc ;
/* Size in bytes of the InfoType data item. */
	uint8 DcmDspVehInfoDataSize ;
/* InfotypeServices_<VEHINFODATA>. where <VEHINFODATA> is the name of the container DcmDspVehInfoData.
 *  In that case, the DcmDspVehInfoDataReadFnc is ignored and the RTE APIs are used. When the parameter
 *  DcmDspVehInfoDataUsePort is false, the DCM calls the function defined in DcmDspVehInfoDataReadFnc.
 */
/* When the parameter DcmDspVehInfoUsePort is set to true the DCM will access the Data using an
 *  R-Port requiring a PortInteface InfotypeServices_<VEHINFODATA>. The R-Port is named
 */
	boolean DcmDspVehInfoDataUsePort ;
} Dcm_DspVehInfoDataType ;

/* This container contains the configuration (parameters) of the "Request vehicle information service"
 *  (service $09).
 */
typedef struct Dcm_DspVehInfoType_tag
{
	Dcm_DspVehInfoDataType* DcmDspVehInfoData ;
/* value of InfoType. */
	uint8 DcmDspVehInfoInfoType ;
} Dcm_DspVehInfoType ;

/* These parameters apply to Diagnostic Service Processing. There will always be one set of these
 *  parameters per DCM.
 */
typedef struct Dcm_DspType_tag
{
	Dcm_DspComControlType* DcmDspComControl ;
	Dcm_DspControlDTCSettingType* DcmDspControlDTCSetting ;
	Dcm_DspDataType* DcmDspData ;
	Dcm_DspDataInfoType* DcmDspDataInfo ;
	Dcm_DspDidType* DcmDspDid ;
	Dcm_DspDidInfoType* DcmDspDidInfo ;
	Dcm_DspDidRangeType* DcmDspDidRange ;
	Dcm_DspMemoryType* DcmDspMemory ;
	Dcm_DspPidType* DcmDspPid ;
/* The DCM will request the control using an R-Port requiring a PortInteface RequestControlServices_<TID>
 *                                                 The R-Port is named RequestControlServices_<TID>
 *                                                 where <TID> is the name of the container DcmDspRequestControl.
 */
	Dcm_DspRequestControlType* DcmDspRequestControl ;
	Dcm_DspRoeType* DcmDspRoe ;
	Dcm_DspRoutineType* DcmDspRoutine ;
	Dcm_DspRoutineInfoType* DcmDspRoutineInfo ;
/* Description
 *                                                 This container contains Rows of DcmDspSecurityRow
 */
	Dcm_DspSecurityType* DcmDspSecurity ;
/* This container contains Rows of DcmDspSessionRow */
	Dcm_DspSessionType* DcmDspSession ;
	Dcm_DspTestResultByObdmidType* DcmDspTestResultByObdmid ;
	Dcm_DspVehInfoType* DcmDspVehInfo ;
/* If set to 0, then no limitation is  applied. */
/* Indicates the maximum allowed DIDs in a single "ReadDataByIdentifier" request. */
	uint16 DcmDspMaxDidToRead ;
/* The resolution of this parameter is one second per count.
 * 
 *                                                 The following values are valid:
 *                                                 00 - FE hex: 0 - 254 s powerDownTime;
 *                                                 FF hex: indicates a failure or time not available.
 */
/* This parameter indicates to the client the minimum time of the  stand-by sequence the server
 *  will remain in the power-down sequence.
 */
	uint8 DcmDspPowerDownTime ;
} Dcm_DspType ;

/* This container contains the configuration (parameters) for Component wide parameters */
typedef struct Dcm_GeneralType_tag
{
/* Preprocessor switch to enable or disable the Development Error Detection (DET) mechanism. */
	boolean DcmDevErrorDetect ;
/* Allows to enable or disable the requested notification mechanism for the Manufacturer. */
	boolean DcmRequestManufacturerNotificationEnabled ;
/* Allows to enable or disable the requested notification mechanism for the Supplier. */
	boolean DcmRequestSupplierNotificationEnabled ;
/* If set to FALSE the DCM will not respond to diagnostic request  that contains a service ID which
 *  is in the range from 0x40 to 0x7F or in the  range from 0xC0 to 0xFF (Response IDs).
 */
	boolean DcmRespondAllRequest ;
/* The AUTOSAR configuration standard is to use SI units, so this parameter is defined as float
 *  value in seconds. DCM configuration tools must convert this float value to the appropriate
 *  value format for the use in the software implementation of DCM.
 * 
 *                                                 min:
 *                                                 A negative value is not allowed.
 * 
 *                                                 upperMultiplicity:
 *                                                 Exactly one TaskTime must be specified per configuration.
 * 
 *                                                 lowerMultiplicity:
 *                                                 Exactly one TaskTime must be specified per configuration.
 */
/* Allow to configure the time for the periodic cyclic task. Please note: This configuration value
 *  shall be equal to the value in the ScheduleManager module.
 */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmTaskTime ;
/* Preprocessor switch to enable or disable the output Version info of the functionality. */
	boolean DcmVersionInfoApi ;
} Dcm_GeneralType ;

/* This container contains the configuration (parameters) for Page Buffer handling */
typedef struct Dcm_PageBufferCfgType_tag
{
/* true = Page buffer handling enabled
 *                                                 false = Page Buffer handling disabled
 */
/* Allow to enable or disable the Page buffer mechanism. */
	boolean DcmPagedBufferEnabled ;
/* This parameter is only relevant if the Page Buffer handling is enabled.
 *                                                 (DcmPagedBufferEnabled = TRUE)
 * 
 *                                                 Defined in the DCM SWS as uint16, this parameter
 *  contains a value in milliseconds.
 * 
 *                                                 The AUTOSAR configuration standard is to use
 *  SI units, so this parameter is defined as float value in seconds. DCM configuration tools must
 *  convert this float value to the appropriate value format for the use in the software implementation
 *  of DCM.
 * 
 *                                                 min:
 *                                                 A negative value is not allowed.
 * 
 *                                                 upperMultiplicity:
 *                                                 Exactly one Timeout must be specified per configuration.
 * 
 *                                                 lowerMultiplicity:
 *                                                 Exactly one Timeout  must be specified per configuration.
 */
/* Allow to configure the Timeout (in ms) towards the application for filling the next page. */
/* in fact, it should be type <float> according to arxml, but only supported in tool side*/
	uint64 DcmPagedBufferTimeout ;
} Dcm_PageBufferCfgType ;

/* This parameter specifies what kind of comparison that is made for the evaluation of the mode
 *  condition.
 */
typedef enum
{
	DCM_EQUALS,
	DCM_EQUALS_NOT
} Dcm_ConditionTypeType ;

/* This container contains the configuration of a mode condition which can be used as argument
 *  in DcmModeRules.
 */
typedef struct Dcm_ModeConditionType_tag
{
	Dcm_ConditionTypeType DcmConditionType ;
/* This parameter references a mode of a ModeDeclarationGroupPrototype provided by a Basic Software
 *  Module used for the condition.
 */
/* Please note that such ModeDeclarationGroupPrototype are owned by a Basic Software Module Description
 *  in the role providedModeGroup.
 */
	/*TODO:MODE-DECLARATION*/void* DcmBswModeRef ;
/* This parameter references a mode in a particular mode request port of a software component that
 *  is used for the condition.
 */
	/*TODO:MODE-DECLARATION*/void* DcmSwcModeRef ;
} Dcm_ModeConditionType ;

/* This parameter specifies the logical operator to be used in the logical expression. If the expression
 *  only consists of a single condition this parameter shall not be used.
 */
typedef enum
{
	DCM_AND,
	DCM_OR
} Dcm_LogicalOperatorType ;

/* This container contains the configuration of a mode rule which represents a logical expression
 *  with DcmModeCondistions or other DcmModeRules as arguments.
 */
typedef struct Dcm_ModeRuleType_tag
{
	Dcm_LogicalOperatorType DcmLogicalOperator ;
/* Optional parameter which defines the NRC to be sent in case the mode rule condition is not valid. */
	uint8 DcmModeRuleNrcValue ;
/* This is a choice reference either to a mode condition or a an other mode rule serving as sub-expression.
 */
	uint8 DcmArgumentRefWhich;
	union
	{
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeCondition */
		Dcm_ModeConditionType* DcmModeCondition;
/* /AUTOSAR/EcucDefs/Dcm/DcmConfigSet/DcmProcessingConditions/DcmModeRule */
		Dcm_ModeRuleType* DcmModeRule;
	} DcmArgumentRef ;
} Dcm_ModeRuleType ;

/* This container contains the configuration ( DSP parameter) for mode arbitration functionality
 *  of the Dcm
 */
typedef struct Dcm_ProcessingConditionsType_tag
{
/* One DcmModeCondition shall contain either one DcmSwcModeRef or one DcmBswModeRef.
 *                                                 Please note that the Dcm acts as well as mode
 *  manager. Therefore the references DcmSwcModeRef or one DcmBswModeRef.
 *                                                 might point to provided ModeDeclarationGroupPrototypes
 *  of the Dcm itself as well as to provided ModeDeclarationGroupPrototypes of other Bsw Modules
 *  or software components.
 */
	Dcm_ModeConditionType* DcmModeCondition ;
/* All arguments are processed with the operator defined by DcmLogicalOperator, for instance:
 *                                                 Argument_A AND Argument_B AND Argument_C
 */
	Dcm_ModeRuleType* DcmModeRule ;
} Dcm_ProcessingConditionsType ;

/* This container contains the configuration parameters and sub containers of the DCM module supporting
 *  multiple configuration sets.
 */
typedef struct Dcm_ConfigSetType_tag
{
/* There must always be one service dispatcher in a DCM. */
	Dcm_DsdType* DcmDsd ;
/* upperMultiplicity:
 *                                         Each DCM configuration must have exactly one DSL configuration.
 * 
 *                                         lowerMultiplicity:
 *                                         Each DCM configuration must have exactly one DSL configuration.
 */
	Dcm_DslType* DcmDsl ;
	Dcm_DspType* DcmDsp ;
	Dcm_GeneralType* DcmGeneral ;
	Dcm_PageBufferCfgType* DcmPageBufferCfg ;
	Dcm_ProcessingConditionsType* DcmProcessingConditions ;
} Dcm_ConfigSetType ;

/* ============================ [ DATAS     ] ====================================================== */
/* ============================ [ DECLARES  ] ====================================================== */
/* ============================ [ LOCALS    ] ====================================================== */
/* ============================ [ FUNCTIONS ] ====================================================== */
#ifdef __cplusplus
}}  /* name space */
#endif
#endif /* DCM_TYPES_H */

